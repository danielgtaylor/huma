{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Huma","text":""},{"location":"#introduction","title":"Introduction","text":"<p>A modern, simple, fast &amp; flexible micro framework for building HTTP REST/RPC APIs in Golang backed by OpenAPI 3 and JSON Schema. Pronounced IPA: /'hju\u02d0m\u0251/.</p>"},{"location":"#goals","title":"Goals","text":"<p>The goals of this project are to provide:</p> <ul> <li>A modern REST or HTTP RPC API backend framework for Go developers<ul> <li>Described by OpenAPI 3.1 &amp; JSON Schema</li> </ul> </li> <li>Incremental adoption for teams with existing services<ul> <li>Bring your own router, middleware, and logging/metrics</li> <li>Extensible OpenAPI &amp; JSON Schema layer to document existing routes</li> </ul> </li> <li>Guard rails to prevent common mistakes</li> <li>Documentation that can't get out of date</li> <li>High-quality generated developer tooling</li> </ul>"},{"location":"#starting-points","title":"Starting Points","text":"<ul> <li> Why Huma        What makes Huma different and why should you use it for your next project?  Learn more </li> </ul> <ul> <li> Tutorial in 5 Minutes      Install <code>huma</code> and have a working API in about five minutes.  Get started </li> </ul> <ul> <li> How To Guides      Learn how to solve specific real-world problems with Huma.  Solve problems </li> </ul> <ul> <li> Features &amp; Reference      Learn about all of Huma's features &amp; how to use them.  Feature docs  Go reference </li> </ul>"},{"location":"features/","title":"Features","text":"<p>Huma is a modern, simple, fast &amp; flexible micro framework for building HTTP REST/RPC APIs in Golang backed by OpenAPI 3 and JSON Schema. Pronounced IPA: /'hju\u02d0m\u0251/. The goals of this project are to provide:</p> <ul> <li>A modern REST or HTTP RPC API backend framework for Go developers<ul> <li>Described by OpenAPI 3.1 &amp; JSON Schema</li> </ul> </li> <li>Incremental adoption for teams with existing services<ul> <li>Bring your own router, middleware, and logging/metrics</li> <li>Extensible OpenAPI &amp; JSON Schema layer to document existing routes</li> </ul> </li> <li>Guard rails to prevent common mistakes</li> <li>Documentation that can't get out of date</li> <li>High-quality generated developer tooling</li> </ul> <p>Features include:</p> <ul> <li>Declarative interface on top of your router of choice:<ul> <li>Operation &amp; model documentation</li> <li>Request params (path, query, or header)</li> <li>Request body</li> <li>Responses (including errors)</li> <li>Response headers</li> </ul> </li> <li>JSON Errors using RFC9457 and <code>application/problem+json</code> by default (but can be changed)</li> <li>Per-operation request size limits with sane defaults</li> <li>Content negotiation between server and client<ul> <li>Support for JSON (RFC 8259) and optional CBOR (RFC 7049) content types via the <code>Accept</code> header with the default config.</li> </ul> </li> <li>Conditional requests support, e.g. <code>If-Match</code> or <code>If-Unmodified-Since</code> header utilities.</li> <li>Optional automatic generation of <code>PATCH</code> operations that support:<ul> <li>RFC 7386 JSON Merge Patch</li> <li>RFC 6902 JSON Patch</li> <li>Shorthand patches</li> </ul> </li> <li>Annotated Go types for input and output models<ul> <li>Generates JSON Schema from Go types</li> <li>Static typing for path/query/header params, bodies, response headers, etc.</li> <li>Automatic input model validation &amp; error handling</li> </ul> </li> <li>Documentation generation using Stoplight Elements</li> <li>Optional CLI built-in, configured via arguments or environment variables<ul> <li>Set via e.g. <code>-p 8000</code>, <code>--port=8000</code>, or <code>SERVICE_PORT=8000</code></li> <li>Startup actions &amp; graceful shutdown built-in</li> </ul> </li> <li>Generates OpenAPI for access to a rich ecosystem of tools<ul> <li>Mocks with API Sprout or Prism</li> <li>SDKs with OpenAPI Generator or oapi-codegen</li> <li>CLI with Restish</li> <li>And plenty more</li> </ul> </li> <li>Generates JSON Schema for each resource using optional <code>describedby</code> link relation headers as well as optional <code>$schema</code> properties in returned objects that integrate into editors for validation &amp; completion.</li> </ul> <p>Mascot</p> <p>Hi there! I'm the happy Huma whale here to provide help. You'll see me leave helpful tips throughout the docs.</p> <p>Official Go package documentation can always be found at https://pkg.go.dev/github.com/danielgtaylor/huma/v2. Read on for an introduction to the various features available in Huma.</p>"},{"location":"features/api-docs/","title":"Generated API Documentation","text":""},{"location":"features/api-docs/#generated-api-docs","title":"Generated API Docs","text":"<p>Huma uses the OpenAPI spec to generate interactive API documentation using third-party tools. By default, Stoplight Elements is used to render the documentation at the API's <code>config.DocsPath</code> which defaults to <code>/docs</code>.</p> <p>You can switch to other documentation renderers using <code>config.DocsRenderer</code>. The following renderers are supported out of the box:</p> <ul> <li><code>huma.DocsRendererStoplightElements</code> (default)</li> <li><code>huma.DocsRendererScalar</code></li> <li><code>huma.DocsRendererSwaggerUI</code></li> </ul> <p></p> <p>Disabling the Docs</p> <p>You can disable the built-in documentation by setting <code>config.DocsPath</code> to an empty string. This allows you to provide your own documentation renderer if you wish.</p> <p>Middleware Conflicts</p> <p>Some middleware can interfere with the documentation renderer's ability to fetch the OpenAPI spec. For example, go-chi/chi's <code>middleware.URLFormat</code> will rewrite URLs that end in <code>.json</code> or <code>.yaml</code> (e.g. <code>/openapi.json</code> -&gt; <code>/openapi</code>), which can lead to 404 errors for the spec. If you encounter this, consider disabling that middleware or configuring it to skip the OpenAPI and documentation paths.</p>"},{"location":"features/api-docs/#customizing-documentation","title":"Customizing Documentation","text":"<p>You can customize the generated documentation by providing your own renderer function to the API adapter or by using the underlying router directly.</p>"},{"location":"features/api-docs/#scalar-docs","title":"Scalar Docs","text":"<p>Scalar Docs provide a featureful and customizable API documentation experience that feels similar to Postman in your browser.</p> code.go<pre><code>router := chi.NewRouter()\nconfig := huma.DefaultConfig(\"Docs Example\", \"1.0.0\")\nconfig.DocsPath = \"\"\n\napi := humachi.New(router, config)\n\nrouter.Get(\"/docs\", func(w http.ResponseWriter, r *http.Request) {\n\t// Please also refer to the \"DocsRendererScalar\" renderer code inside api.go on what to return here\n\tcsp := []string{\n\t\t\"default-src 'none'\",\n\t\t\"base-uri 'none'\",\n\t\t\"connect-src 'self'\",\n\t\t\"form-action 'none'\",\n\t\t\"frame-ancestors 'none'\",\n\t\t\"sandbox allow-same-origin allow-scripts\",\n\t\t\"script-src 'unsafe-eval' https://unpkg.com/@scalar/api-reference@1.44.20/dist/browser/standalone.js\", // TODO: Somehow drop 'unsafe-eval'\n\t\t\"style-src 'unsafe-inline'\", // TODO: Somehow drop 'unsafe-inline'\n\t}\n\tw.Header().Set(\"Content-Security-Policy\", strings.Join(csp, \"; \"))\n\tw.Header().Set(\"Content-Type\", \"text/html\")\n\tw.Write([]byte(`&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;meta name=\"referrer\" content=\"no-referrer\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;title&gt;API Reference&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script id=\"api-reference\" data-url=\"/openapi.json\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://unpkg.com/@scalar/api-reference@1.44.20/dist/browser/standalone.js\" crossorigin integrity=\"sha384-tMz7GAo6dMy55x9tLFtH+sHtogji6Scmb+feBR31TAHmvSPRUTboK9H3M5NFaP4R\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;`))\n})\n</code></pre> <p></p>"},{"location":"features/api-docs/#stoplight-elements","title":"Stoplight Elements","text":"<p>You can customize the default docs by providing your own HTML so you can set the layout, styles, colors, etc as needed.</p> code.go<pre><code>router := chi.NewRouter()\nconfig := huma.DefaultConfig(\"Docs Example\", \"1.0.0\")\nconfig.DocsPath = \"\"\n\napi := humachi.New(router, config)\n\nrouter.Get(\"/docs\", func(w http.ResponseWriter, r *http.Request) {\n\t// Please refer to the \"DocsRendererStoplightElements\" renderer code inside api.go on what to return here\n})\n</code></pre> <p></p>"},{"location":"features/api-docs/#swaggerui","title":"SwaggerUI","text":"<p>SwaggerUI is an older but proven documentation generator that is widely used in the industry. It provides a more traditional API documentation experience.</p> code.go<pre><code>router := chi.NewRouter()\nconfig := huma.DefaultConfig(\"Docs Example\", \"1.0.0\")\nconfig.DocsPath = \"\"\n\napi := humachi.New(router, config)\n\nrouter.Get(\"/docs\", func(w http.ResponseWriter, r *http.Request) {\n\t// Please refer to the \"DocsRendererSwaggerUI\" renderer code inside api.go on what to return here\n})\n</code></pre> <p></p>"},{"location":"features/api-docs/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Config</code> the API config</li> <li><code>huma.DefaultConfig</code> the default API config</li> </ul> </li> </ul>"},{"location":"features/auto-patch/","title":"Auto Patch","text":""},{"location":"features/auto-patch/#auto-patch_1","title":"Auto Patch","text":"<p>If a <code>GET</code> and a <code>PUT</code> exist for the same resource, but no <code>PATCH</code> exists at server start up, then a <code>PATCH</code> operation can be generated for you to make editing more convenient for clients. You can opt-in to this behavior with the <code>autopatch</code> package:</p> <pre><code>import \"github.com/danielgtaylor/huma/v2/autopatch\"\n\n// ...\n\n// Later in the code *after* registering operations...\nautopatch.AutoPatch(api)\n</code></pre> <p>If the <code>GET</code> returns an <code>ETag</code> or <code>Last-Modified</code> header, then these will be used to make conditional requests on the <code>PUT</code> operation to prevent distributed write conflicts that might otherwise overwrite someone else's changes.</p> <p>The following formats are supported out of the box, selected via the <code>Content-Type</code> header:</p> <ul> <li>JSON Merge Patch <code>application/merge-patch+json</code></li> <li>Shorthand Merge Patch <code>application/merge-patch+shorthand</code></li> <li>JSON Patch <code>application/json-patch+json</code></li> </ul> <p>Merge on Steroids</p> <p>You can think of the Shorthand Merge Patch as an extension to the JSON merge patch with support for field paths, arrays, and a few other features. Patches like this are possible, appending an item to an array (creating it if needed):</p> <pre><code>{\n\tfoo.bar[]: \"baz\",\n}\n</code></pre> <p>If the <code>PATCH</code> request has no <code>Content-Type</code> header, or uses <code>application/json</code> or a variant thereof, then JSON Merge Patch is assumed.</p>"},{"location":"features/auto-patch/#disabling-auto-patch","title":"Disabling Auto Patch","text":"<p>The auto patch feature can be disabled per resource by setting metadata on an operation:</p> code.go<pre><code>// Register an operation that won't get a PATCH generated.\nhuma.Register(api, huma.Operation{\n\tOperationID: \"get-greeting\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/greeting/{name}\",\n\tSummary:     \"Get a greeting\",\n\tMetadata: map[string]interface{}{\n\t\t\"autopatch\": false,\n\t},\n}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t// ...\n})\n</code></pre>"},{"location":"features/auto-patch/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>autopatch</code> package</li> </ul> </li> <li>External Links<ul> <li>HTTP PATCH Method</li> <li>RFC7386 JSON Merge Patch</li> <li>Shorthand Merge Patch</li> <li>RFC6902 JSON Patch</li> </ul> </li> </ul>"},{"location":"features/bring-your-own-router/","title":"BYOR (Bring Your Own Router)","text":""},{"location":"features/bring-your-own-router/#byor-bring-your-own-router_1","title":"BYOR (Bring Your Own Router)","text":"<p>Huma is designed to be router-agnostic to enable incremental adoption in existing and new services across a large number of organizations. This means you can use any router you want, or even write your own. The only requirement is an implementation of a small <code>huma.Adapter</code> interface. This is how Huma integrates with your router.</p> <p>Adapters are in the <code>adapters</code> directory and named after the router they support. Many common routers are supported out of the box (in alphabetical order):</p> <ul> <li>BunRouter via <code>humabunrouter</code></li> <li>chi via <code>humachi</code></li> <li>Echo via <code>humaecho</code></li> <li>Fiber via <code>humafiber</code></li> <li>gin via <code>humagin</code></li> <li>Go 1.22+ <code>http.ServeMux</code> via <code>humago</code> (requires <code>go 1.22</code> or newer in <code>go.mod</code>)</li> <li>gorilla/mux via <code>humamux</code></li> <li>httprouter via <code>humahttprouter</code></li> </ul> <p>New Adapters</p> <p>Writing your own adapter is quick and simple, and PRs are accepted for additional adapters to be built-in.</p>"},{"location":"features/bring-your-own-router/#chi-example","title":"Chi Example","text":"<p>Adapters are instantiated by wrapping your router and providing a Huma configuration object which describes the API. Here is a simple example using Chi:</p> main.go<pre><code>import (\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Create your router.\nrouter := chi.NewMux()\n\n// Wrap the router with Huma to create an API instance.\napi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n// Register your operations with the API.\n// ...\n\n// Start the server!\nhttp.ListenAndServe(\":8888\", r)\n</code></pre> <p>For existing services using Chi v4, you can use <code>humachi.NewV4</code> instead.</p>"},{"location":"features/bring-your-own-router/#route-groups-base-urls","title":"Route Groups &amp; Base URLs","text":"<p>Many routers support grouping of operations under a common base URL path. This is useful for versioning APIs or grouping related operations together. Huma's router adapters can be instantiated using these route groups. You can set the <code>OpenAPI().Servers</code> slice to include the base URL path for the group, enabling the correct URLs to be generated for the docs &amp; schemas. Here is an example:</p> main.go<pre><code>mux := chi.NewMux()\nmux.Route(\"/api\", func(r chi.Router) {\n\tconfig := huma.DefaultConfig(\"My API\", \"1.0.0\")\n\tconfig.Servers = []*huma.Server{\n\t\t{URL: \"https://example.com/api\"},\n\t}\n\tapi = humachi.New(r, config)\n\n\t// Register operations...\n\thuma.Get(api, \"/demo\", func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t// TODO: Implement me!\n\t\treturn nil, nil\n\t})\n})\nhttp.ListenAndServe(\"localhost:8888\", mux)\n</code></pre> <p>The OpenAPI, docs, schemas, etc will all be generated with the <code>/api</code> prefix.</p> Shell<pre><code># Call the demo operation\nrestish :8888/api/demo\n\n# Get the OpenAPI\nrestish :8888/api/openapi.yaml\n</code></pre> <p>The following scenarios are supported:</p> Server Base URL Route Group Register Path Client Request &amp; Description - - <code>/api/demo</code> <code>GET /api/demo</code>  The default simple case. <code>/api</code> - <code>/demo</code> <code>GET /api/demo</code> \u2192 <code>GET /demo</code>  E.g. an API gateway which forwards requests to the service after stripping the <code>/api</code> prefix off the path. <code>/api</code> <code>/api</code> <code>/demo</code> <code>GET /api/demo</code>  Unmodified request with route groups."},{"location":"features/bring-your-own-router/#dive-deeper","title":"Dive Deeper","text":"<p>The adapter converts a router-specific request context like <code>http.Request</code> or <code>fiber.Ctx</code> into the router-agnostic <code>huma.Context</code>, which is then used to call your operation's handler function.</p> <pre><code>graph LR\n\tRequest([Request])\n\tOperationHandler[Operation Handler]\n\n\tRequest --&gt; Router\n\tRouter --&gt;|http.Request&lt;br&gt;fiber.Ctx&lt;br&gt;etc| huma.Adapter\n\tsubgraph huma.API\n\t\thuma.Adapter --&gt;|huma.Context| OperationHandler\n\tend</code></pre> <ul> <li>Features<ul> <li>Registering operations</li> </ul> </li> <li>Reference<ul> <li><code>huma.Context</code> a router-agnostic request/response context</li> <li><code>huma.Adapter</code> the router-agnostic adapter interface</li> <li><code>huma.API</code> the API instance</li> <li><code>huma.NewAPI</code> creates an API instance (called by adapters)</li> <li><code>huma.Register</code> registers new operations</li> <li><code>huma.OpenAPI</code> configures things like the server URLs &amp; base path</li> </ul> </li> </ul>"},{"location":"features/cli-auto-config/","title":"CLI AutoConfig","text":"<p>Huma includes built-in support for an OpenAPI 3 extension that enables CLI auto-configuration. This allows tools like Restish to automatically configure themselves to talk to your API with the correct endpoints, authentication mechanism, etc without the user needing to know anything about your API.</p> <pre><code>o := api.OpenAPI()\no.Components.SecuritySchemes[\"my-scheme\"] = &amp;huma.SecurityScheme{\n\tType: \"oauth2\",\n\t// ... security scheme definition ...\n}\no.Extensions[\"x-cli-autoconfig\"] = huma.AutoConfig{\n\tSecurity: \"my-scheme\",\n\tParams: map[string]string{\n\t\t\"client_id\": \"abc123\",\n\t\t\"authorize_url\": \"https://example.tld/authorize\",\n\t\t\"token_url\": \"https://example.tld/token\",\n\t\t\"scopes\": \"read,write\",\n\t}\n}\n</code></pre> <p>See the CLI AutoConfiguration documentation for more info, including how to ask the user for custom parameters.</p>"},{"location":"features/cli/","title":"Service CLI","text":""},{"location":"features/cli/#service-cli_1","title":"Service CLI","text":"<p>Huma ships with a built-in lightweight utility to wrap your service with a CLI, enabling you to run it with different arguments and easily write custom commands to do things like print out the OpenAPI or run on-demand database migrations.</p> <p>The CLI options use a similar strategy to input &amp; output structs, enabling you to use the same pattern for validation and documentation of command line arguments. It uses Cobra under the hood, enabling custom commands and including automatic environment variable binding and more.</p> main.go<pre><code>// First, define your input options.\ntype Options struct {\n\tDebug bool   `doc:\"Enable debug logging\"`\n\tHost  string `doc:\"Hostname to listen on.\"`\n\tPort  int    `doc:\"Port to listen on.\" short:\"p\" default:\"8888\"`\n}\n\nfunc main() {\n\t// Then, create the CLI.\n\tcli := humacli.New(func(hooks humacli.Hooks, opts *Options) {\n\t\tfmt.Printf(\"I was run with debug:%v host:%v port%v\\n\",\n\t\t\topts.Debug, opts.Host, opts.Port)\n\t})\n\n\t// Run the thing!\n\tcli.Run()\n}\n</code></pre> <p>You can then run the CLI and see the results:</p> Terminal<pre><code>// Run with defaults\n$ go run main.go\nI was run with debug:false host: port:8888\n\n// Run with options\n$ go run main.go --debug=true --host=localhost --port=8000\nI was run with debug:true host:localhost port:8000\n</code></pre> <p>To do useful work, you will want to register a handler for the default start command and optionally a way to gracefully shutdown the server:</p> main.go<pre><code>cli := humacli.New(func(hooks humacli.Hooks, opts *Options) {\n\t// Set up the router and API\n\t// ...\n\n\t// Create the HTTP server.\n\tserver := http.Server{\n\t\tAddr:    fmt.Sprintf(\":%d\", options.Port),\n\t\tHandler: router,\n\t}\n\n\thooks.OnStart(func() {\n\t\t// Start your server here\n\t\tserver.ListenAndServe()\n\t})\n\n\thooks.OnStop(func() {\n\t\t// Gracefully shutdown your server here\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\tserver.Shutdown(ctx)\n\t})\n})\n</code></pre> <p>Naming</p> <p>Option fields are automatically converted to <code>--kebab-casing</code> for use on the command line. If you want to use a different name, use the <code>name</code> struct tag to override the default behavior!</p>"},{"location":"features/cli/#passing-options","title":"Passing Options","text":"<p>Options can be passed explicitly as command-line arguments to the service or they can be provided by environment variables prefixed with <code>SERVICE_</code>. For example, to run the service on port 8000:</p> <pre><code># Example passing command-line args\n$ go run main.go --port=8000\n\n# Short arguments are also supported\n$ go run main.go -p 8000\n\n# Example passing by environment variables\n$ SERVICE_PORT=8000 go run main.go\n</code></pre> <p>Precedence</p> <p>If both environment variable and command-line arguments are present, then command-line arguments take priority.</p>"},{"location":"features/cli/#custom-options","title":"Custom Options","text":"<p>Custom options are defined by adding to your options struct. The following types are supported:</p> Type Example Inputs <code>bool</code> <code>true</code>, <code>false</code> <code>int</code> / <code>int64</code> <code>1234</code>, <code>5</code>, <code>-1</code> <code>string</code> <code>prod</code>, <code>http://api.example.tld/</code> <code>time.Duration</code> <code>500ms</code>, <code>3s</code>, <code>1h30m</code> <p>The following struct tags are available:</p> Tag Description Example <code>default</code> Default value (parsed automatically) <code>default:\"123\"</code> <code>doc</code> Describe the option <code>doc:\"Who to greet\"</code> <code>name</code> Override the name of the option <code>name:\"my-option-name\"</code> <code>short</code> Single letter short name for the option <code>short:\"p\"</code> for <code>-p</code> <p>Here is an example of how to use them:</p> main.go<pre><code>type Options struct {\n\tDebug bool   `doc:\"Enable debug logging\"`\n\tHost  string `doc:\"Hostname to listen on.\"`\n\tPort  int    `doc:\"Port to listen on.\" short:\"p\" default:\"8888\"`\n}\n</code></pre>"},{"location":"features/cli/#custom-commands","title":"Custom Commands","text":"<p>You can access the root <code>cobra.Command</code> via <code>cli.Root()</code> and add new custom commands via <code>cli.Root().AddCommand(...)</code>. For example, to have a command print out the generated OpenAPI:</p> main.go<pre><code>var api huma.API\n\n// ... set up the CLI, create the API wrapping the router ...\n\ncli.Root().AddCommand(&amp;cobra.Command{\n\tUse:   \"openapi\",\n\tShort: \"Print the OpenAPI spec\",\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tb, err := api.OpenAPI().YAML()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(string(b))\n\t},\n})\n</code></pre> <p>Note</p> <p>You can use <code>api.OpenAPI().DowngradeYAML()</code> to output OpenAPI 3.0 instead of 3.1 for tools that don't support 3.1 yet.</p> <p>Now you can run your service and use the new command: <code>go run . openapi</code>. Notice that it never starts the server; it just runs your command handler code. Some ideas for custom commands:</p> <ul> <li>Print the OpenAPI spec</li> <li>Print JSON Schemas</li> <li>Run database migrations</li> <li>Run customer scenario tests</li> <li>Bundle common actions into a single utility command, like adding a new user</li> </ul>"},{"location":"features/cli/#custom-commands-with-options","title":"Custom Commands with Options","text":"<p>If you want to access your custom options struct with custom commands, use the <code>huma.WithOptions(func(cmd *cobra.Command, args []string, options *YourOptions)) func(cmd *cobra.Command, args []string)</code> utility function. It ensures the options are parsed and available before running your command.</p> <p>More Customization</p> <p>You can also overwrite <code>cli.Root().Run</code> to completely customize how you run the server. Or just ditch the <code>cli</code> package altogether!</p>"},{"location":"features/cli/#app-name-version","title":"App Name &amp; Version","text":"<p>You can set the app name and version to be used in the help output and version command. By default, the app name is the name of the binary and the version is unset. You can set them using the root <code>cobra.Command</code>'s <code>Use</code> and <code>Version</code> fields:</p> main.go<pre><code>// cli := humacli.New(...)\n\ncmd := cli.Root()\ncmd.Use = \"appname\"\ncmd.Version = \"1.0.1\"\n\ncli.Run()\n</code></pre> <p>Then you will see something like this:</p> Terminal<pre><code>$ go run ./demo --help\nUsage:\n  appname [flags]\n\nFlags:\n  -h, --help            help for appname\n  -p, --port int         (default 8888)\n  -v, --version         version for appname\n\n$ go run ./demo --version\nappname version 1.0.1\n</code></pre>"},{"location":"features/cli/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Tutorial<ul> <li>Service Configuration Tutorial includes a working CLI example</li> </ul> </li> <li>How-To<ul> <li>Graceful Shutdown on service stop</li> </ul> </li> <li>Reference<ul> <li><code>humacli.CLI</code> the CLI instance</li> <li><code>humacli.New</code> creates a new CLI instance</li> <li><code>humacli.Hooks</code> for startup / shutdown</li> <li><code>humacli.WithOptions</code> wraps a command with options parsing</li> <li><code>huma.API</code> the API instance</li> </ul> </li> <li>External Links<ul> <li>Cobra CLI library</li> </ul> </li> </ul>"},{"location":"features/conditional-requests/","title":"Conditional Requests","text":""},{"location":"features/conditional-requests/#conditional-requests_1","title":"Conditional Requests","text":"<p>There are built-in utilities for handling conditional requests, which serve two broad purposes:</p> <ol> <li>Sparing bandwidth on reading a document that has not changed, i.e. \"only send if the version is different from what I already have\".</li> <li>Preventing multiple writers from clobbering each other's changes, i.e. \"only save if the version on the server matches what I saw last\".</li> </ol> <p>Adding support for handling conditional requests requires four steps:</p> <ol> <li>Import the <code>github.com/danielgtaylor/huma/v2/conditional</code> package.</li> <li>(optional) Add the response definition (<code>304 Not Modified</code> for reads or <code>412 Precondition Failed</code> for writes)</li> <li>Add <code>conditional.Params</code> to your input struct.</li> <li>Check if conditional params were passed and handle them. The <code>HasConditionalParams()</code> and <code>PreconditionFailed(...)</code> methods can help with this.</li> </ol>"},{"location":"features/conditional-requests/#example","title":"Example","text":"<p>Implementing a conditional read might look like:</p> <pre><code>huma.Register(api, huma.Operation{\n\tOperationID: \"get-resource\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/resource\",\n\tSummary:     \"Get a resource\",\n}, func(ctx context.Context, input struct {\n\tconditional.Params\n}) (*YourOutput, error) {\n\tif input.HasConditionalParams() {\n\t\t// TODO: Get the ETag and last modified time from the resource.\n\t\tetag := \"\"\n\t\tmodified := time.Time{}\n\n\t\t// If preconditions fail, abort the request processing. Response status\n\t\t// codes are already set for you, but you can optionally provide a body.\n\t\t// Returns an HTTP 304 not modified.\n\t\tif err := input.PreconditionFailed(etag, modified); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Otherwise do the normal request processing here...\n\t\t// ...\n\t}\n})\n</code></pre> <p>Conditional Request Efficiency</p> <p>Note that it is more efficient to construct custom DB queries to handle conditional requests, however Huma is not aware of your database. The built-in conditional utilities are designed to be generic and work with any data source, and are a quick and easy way to get started with conditional request handling.</p>"},{"location":"features/conditional-requests/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>conditional</code> package</li> <li><code>conditional.Params</code></li> </ul> </li> <li>External Links<ul> <li>Conditional Requests</li> </ul> </li> </ul>"},{"location":"features/groups/","title":"Groups","text":""},{"location":"features/groups/#groups_1","title":"Groups","text":"<p>Operations can be grouped under common route prefixes and share middleware, operation modifier functions, and response transformers. This is done using the <code>huma.Group</code> wrapper around a <code>huma.API</code> instance, which can then be passed to <code>huma.Register</code> and its convenience wrappers like <code>huma.Get</code>, <code>huma.Post</code>, etc.</p> <pre><code>grp := huma.NewGroup(api, \"/v1\")\ngrp.UseMiddleware(authMiddleware)\n\nhuma.Get(grp, \"/users\", func(ctx context.Context, input *struct{}) (*UsersResponse, error) {\n\t// ...\n})\n</code></pre> <p>The above example will register a <code>GET /v1/users</code> operation with the <code>authMiddleware</code> running before the operation handler.</p> <p>Groups &amp; Documentation</p> <p>Groups assume that <code>huma.Register</code> or one of its convenience wrappers is used to register operations. If you are not, then you may need to invoke <code>group.DocumentOperation(*huma.Operation)</code> to ensure that the operation is documented correctly.</p>"},{"location":"features/groups/#group-features","title":"Group Features","text":"<p>Groups support the following features:</p> <ul> <li>One or more path prefixes for all operations in the group.</li> <li>Middleware that runs before each operation in the group.</li> <li>Operation modifiers that run at operation registration time.</li> <li>Response transformers that run after each operation in the group.</li> </ul>"},{"location":"features/groups/#prefixes","title":"Prefixes","text":"<p>Groups can have one or more path prefixes that are prepended to all operations in the group. This is useful for grouping related operations under a common prefix and is typically done with a single prefix.</p> <pre><code>grp := huma.NewGroup(api, \"/prefix1\", \"/prefix2\", \"...\")\n</code></pre> <p>This is just a convenience for the following equivalent code:</p> <pre><code>grp := huma.NewGroup(api)\ngrp.UseModifier(huma.PrefixModifier(\"/prefix1\", \"/prefix2\", \"...\"))\n</code></pre> <p>The built-in <code>huma.PrefixModifier</code> will adjust the operation's ID and tags when more than one prefix is used. If you with to customize this behavior, you can write your own operation modifier.</p>"},{"location":"features/groups/#middleware","title":"Middleware","text":"<p>Middleware functions are run before each operation handler in the group. They can be used for common tasks like authentication, logging, and error handling. Middleware functions are registered using the <code>UseMiddleware</code> method on a group.</p> <pre><code>grp.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t// Do something before the operation runs\n\tnext(ctx)\n})\n</code></pre>"},{"location":"features/groups/#operation-modifiers","title":"Operation Modifiers","text":"<p>Operation modifiers are functions that run at operation registration time. They can be used to modify the operation before it is registered. Operation modifiers are registered using the <code>UseModifier</code> method on a group.</p> <pre><code>grp.UseModifier(func(op *huma.Operation, next func(*huma.Operation)) {\n\top.Summary = \"A summary for all operations in this group\"\n\top.Tags = []string{\"my-tag\"}\n    next(op)\n})\n</code></pre> <p>There is also a simplified form you can use:</p> <pre><code>grp.UseSimpleModifier(func(op *huma.Operation) {\n\top.Summary = \"A summary for all operations in this group\"\n\top.Tags = []string{\"my-tag\"}\n})\n</code></pre>"},{"location":"features/groups/#response-transformers","title":"Response Transformers","text":"<p>Response transformers are functions that run after each operation handler in the group. They can be used to modify the response before it is returned to the client. Response transformers are registered using the <code>UseResponseTransformer</code> method on a group.</p> <pre><code>grp.UseTransformer(func(ctx huma.Context, status string, v any) (any, error) {\n\t// Do something with the output\n\treturn output, nil\n})\n</code></pre>"},{"location":"features/groups/#customizing-documentation","title":"Customizing Documentation","text":"<p>Groups implement <code>huma.OperationDocumenter</code> which bypasses the normal flow of documentation generation and instead calls a function. This allows you to customize the documentation for all operations in the group. You can override the <code>DocumentOperation</code> method to customize the documentation if needed:</p> <pre><code>type MyGroup huma.Group\n\nfunc (g *MyGroup) DocumentOperation(op *huma.Operation) {\n\tg.ModifyOperation(op, func(op *huma.Operation) {\n\t\tif documenter, ok := g.API.(huma.OperationDocumenter); ok {\n\t\t\t// Support nested operation documenters (i.e. groups of groups).\n\t\t\tdocumenter.DocumentOperation(op)\n\t\t} else {\n\t\t\t// Default behavior to add operations.\n\t\t\tif op.Hidden {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tg.OpenAPI().AddOperation(op)\n\t\t}\n\t})\n}\n</code></pre>"},{"location":"features/groups/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Features<ul> <li>Operations registration &amp; workflows</li> <li>Middleware for operations</li> <li>Response Transformers to modify response bodies</li> </ul> </li> <li>Reference<ul> <li><code>huma.Register</code> register an operation</li> <li><code>huma.Middlewares</code> list of middleware</li> <li><code>huma.Transformer</code> response transformers</li> <li><code>huma.OperationDocumenter</code> to customize OpenAPI generation</li> <li><code>huma.API</code> the API instance</li> </ul> </li> </ul>"},{"location":"features/json-schema-registry/","title":"JSON Schema & Registry","text":""},{"location":"features/json-schema-registry/#json-schema","title":"JSON Schema","text":"<p>Using the default Huma config (or manually via the <code>huma.SchemaLinkTransformer</code>), each resource operation returns a <code>describedby</code> HTTP link relation header which references a JSON-Schema file. These schemas use the <code>config.SchemasPath</code> to serve their content. For example:</p> HTTP Response<pre><code>Link: &lt;/schemas/Note.json&gt;; rel=\"describedby\"\n</code></pre> <p>Object resources (i.e. not arrays or simple scalars) can also optionally return a <code>$schema</code> property with such a link, which enables the described-by relationship to outlive the HTTP request (i.e. saving the body to a file for later editing) and enables some editors like VSCode to provide code completion and validation as you type.</p> response.json<pre><code>{\n\t\"$schema\": \"http://localhost:8888/schemas/Note.json\",\n\t\"title\": \"I am a note title\",\n\t\"contents\": \"Example note contents\",\n\t\"labels\": [\"todo\"]\n}\n</code></pre> <p>Operations which accept objects as input will ignore the <code>$schema</code> property, so it is safe to submit back to the API, aka \"round-trip\" the data.</p>"},{"location":"features/json-schema-registry/#disabling-schema","title":"Disabling <code>$schema</code>","text":"<p>If you want to disable the <code>$schema</code> property and the <code>Link</code> header in responses, you can set the <code>CreateHooks</code> to <code>nil</code> in your configuration before creating the API. This prevents the default <code>SchemaLinkTransformer</code> from being registered.</p> <pre><code>config := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig.CreateHooks = nil\n\n// Create the API using the config...\n</code></pre> <p>Alternatively, you can manually manage your <code>Transformers</code> and <code>OnAddOperation</code> hooks in a custom configuration if you only want to disable one of them.</p> <p>Editing</p> <p>The <code>$schema</code> field is incredibly powerful when paired with Restish's edit command, giving you a quick and easy way to edit strongly-typed resources in your favorite editor.</p>"},{"location":"features/json-schema-registry/#schema-registry","title":"Schema Registry","text":"<p>Huma uses a customizable registry to keep track of all the schemas that have been generated from Go structs. This is used to avoid generating the same schema multiple times, and to provide a way to reference schemas by name for OpenAPI operations &amp; hosted JSON Schemas.</p> <p>The default schema implementation uses a <code>map</code> to store schemas by name,generated from the Go type name without the package name. This supports recursive schemas and generates simple names like <code>Thing</code> or <code>ThingList</code>.</p> <p>Schema Names</p> <p>Note that by design the default registry does not support multiple models with the same name in different packages. For example, adding both <code>foo.Thing</code> and <code>bar.Thing</code> will result in a conflict. You can work around this by defining a new type like <code>type BarThing bar.Thing</code> and using that instead, or using a custom registry naming function.</p>"},{"location":"features/json-schema-registry/#custom-registry","title":"Custom Registry","text":"<p>You can create your own registry with custom behavior by implementing the <code>huma.Registry</code> interface and setting it on <code>config.OpenAPI.Components.Schemas</code> when creating your API.</p>"},{"location":"features/json-schema-registry/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Schema</code> is a JSON Schema</li> <li><code>huma.Registry</code> generates &amp; stores JSON Schemas</li> <li><code>huma.DefaultSchemaNamer</code> names schemas from types</li> <li><code>huma.Config</code> the API config</li> <li><code>huma.DefaultConfig</code> the default API config</li> <li><code>huma.OpenAPI</code> the OpenAPI spec</li> <li><code>huma.Components</code> contains the <code>Schemas</code> registry</li> </ul> </li> <li>External Links<ul> <li>JSON Schema spec</li> <li>OpenAPI 3.1 Components Object</li> </ul> </li> <li>See Also<ul> <li>Model Validation utility to validate custom JSON objects</li> </ul> </li> </ul>"},{"location":"features/middleware/","title":"Middleware","text":""},{"location":"features/middleware/#middleware_1","title":"Middleware","text":"<p>Huma has support for two variants of middleware:</p> <ol> <li>Router-specific - works at the router level, i.e. before router-agnostic middleware. You can use any middleware that is implemented for your router.</li> <li>Router-agnostic - runs in the Huma processing chain, i.e. after calls to router-specific middleware.</li> </ol> <pre><code>graph LR\n\tRequest([Request])\n\tRouterSpecificMiddleware[Router-Specific Middleware]\n\tHumaMiddleware[Huma Middleware]\n\tOperationHandler[Operation Handler]\n\n\tRequest --&gt; RouterSpecificMiddleware\n\tRouterSpecificMiddleware --&gt; HumaMiddleware\n\tsubgraph Huma\n\t\tHumaMiddleware --&gt; OperationHandler\n\tend</code></pre>"},{"location":"features/middleware/#router-specific","title":"Router-specific","text":"<p>Each router implementation has its own middlewares, you can use these as you normally would before creating the Huma API instance.</p> <p>Chi router example:</p> code.go<pre><code>router := chi.NewMux()\nrouter.Use(jwtauth.Verifier(tokenAuth))\napi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n</code></pre> <p>Fiber router example:</p> code.go<pre><code>app := fiber.New()\napp.Use(logger.New())\napi := humafiber.New(app, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n</code></pre> <p>Huma v1</p> <p>Huma v1 middleware is compatible with Chi v4, so if you use that router with Huma v2 you can continue to use the Huma v1 middleware. See <code>humachi.NewV4</code>.</p>"},{"location":"features/middleware/#router-agnostic","title":"Router-agnostic","text":"<p>You can write you own Huma middleware without any dependency to the specific router implementation. This uses the router-agnostic <code>huma.Context</code> interface, which exposes the request and response properties to your middleware.</p> <p>Example:</p> code.go<pre><code>func MyMiddleware(ctx huma.Context, next func(huma.Context)) {\n\t// Set a custom header on the response.\n\tctx.SetHeader(\"My-Custom-Header\", \"Hello, world!\")\n\n\t// Call the next middleware in the chain. This eventually calls the\n\t// operation handler as well.\n\tnext(ctx)\n}\n\nfunc NewHumaAPI() huma.API {\n\t// ...\n\tapi := humachi.New(router, config)\n\tapi.UseMiddleware(MyMiddleware)\n\n\t// Register the handler after UseMiddleware() for the middleware to take effect\n\thuma.Get(api, \"/greeting/{name}\", handler.GreetingGetHandler)\n}\n</code></pre>"},{"location":"features/middleware/#unwrapping","title":"Unwrapping","text":"<p>While generally not recommended, if you need to access the underlying router-specific request and response objects, you can <code>Unwrap()</code> them using the router-specific adapter package you used to create the API instance (e.g. <code>humachi.Unwrap()</code> for Chi or <code>humago.Unwrap()</code> for Go's <code>http</code> package):</p> code.go<pre><code>func MyMiddleware(ctx huma.Context, next func(huma.Context)) {\n\t// Unwrap the request and response objects.\n\tr, w := humago.Unwrap(ctx)\n\n\t// Do something with the request and response objects.\n\totherMiddleware(func (_ http.Handler) {\n\t\t// Note this assumes the request/response are modified in-place.\n\t\tnext(ctx)\n\t}).ServeHTTP(w, r)\n}\n</code></pre> <p>This can be useful when migrating a large existing project to Huma as you can apply router-specific middleware to individual operations through router-agnostic middleware on the <code>huma.Operation.Middleware</code> field.</p>"},{"location":"features/middleware/#context-values","title":"Context Values","text":"<p>The <code>huma.Context</code> interface provides a <code>Context()</code> method to retrieve the underlying request <code>context.Context</code> value. This can be used to retrieve context values in middleware and operation handlers, such as request-scoped loggers, metrics, or user information.</p> code.go<pre><code>if v, ok := ctx.Context().Value(\"some-key\").(string); ok {\n\t// Do something with `v`!\n}\n</code></pre> <p>You can also wrap the <code>huma.Context</code> to provide additional or override functionality. Some utilities are provided for this, including <code>huma.WithValue</code>:</p> code.go<pre><code>func MyMiddleware(ctx huma.Context, next func(huma.Context)) {\n\t// Wrap the context to add a value.\n\tctx = huma.WithValue(ctx, \"some-key\", \"some-value\")\n\n\t// Call the next middleware in the chain. This eventually calls the\n\t// operation handler as well.\n\tnext(ctx)\n}\n</code></pre> <p>Then you can get the value in the handler context:</p> handler.go<pre><code>huma.Get(api, \"/greeting/{name}\", func(ctx context.Context, input *struct{\n\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t}) (*GreetingOutput, error) {\n\t\t// \"some-value\"\n\t\tctx.Value(\"some-key\")\n\t\tresp := &amp;GreetingOutput{}\n\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\treturn resp, nil\n\t})\n</code></pre>"},{"location":"features/middleware/#cookies","title":"Cookies","text":"<p>You can use the <code>huma.Context</code> interface along with <code>huma.ReadCookie</code> or <code>huma.ReadCookies</code> to access cookies from middleware, and can also write cookies by adding <code>Set-Cookie</code> headers in the response:</p> <pre><code>func MyMiddleware(ctx huma.Context, next func(huma.Context)) {\n\t// Read a cookie by name.\n\tsessionCookie := huma.ReadCookie(ctx, \"session\")\n\tfmt.Println(sessionCookie)\n\n\t// Read all the cookies from the request.\n\tcookies := huma.ReadCookies(ctx)\n\tfmt.Println(cookies)\n\n\t// Set a cookie in the response. Using `ctx.AppendHeader` won't overwrite\n\t// any existing headers, for example if other middleware might also set\n\t// headers or if this code were moved after the `next` call and the operation\n\t// might set the same header. You can also call `ctx.AppendHeader` multiple\n\t// times to write more than one cookie.\n\tcookie := http.Cookie{\n\t\tName:  \"session\",\n\t\tValue: \"123\",\n\t}\n\tctx.AppendHeader(\"Set-Cookie\", cookie.String())\n\n\t// Call the next middleware in the chain. This eventually calls the\n\t// operation handler as well.\n\tnext(ctx)\n}\n</code></pre>"},{"location":"features/middleware/#errors","title":"Errors","text":"<p>If your middleware encounters an error, you can stop the processing of the next middleware or operation handler by skipping the call to <code>next</code> and writing an error response.</p> <p>The <code>huma.WriteErr(api, ctx, status, message, ...error)</code> function can be used to write nice structured error responses which respect client-driven content negotiation for marshaling:</p> code.go<pre><code>func MyMiddleware(ctx huma.Context, next func(ctx huma.Context)) {\n\t// If there is a query parameter \"error=true\", then return an error\n\tif ctx.Query(\"error\") == \"true\" {\n\t\thuma.WriteErr(api, ctx, http.StatusInternalServerError,\n\t\t\t\"Some friendly message\", fmt.Errorf(\"error detail\"),\n\t\t)\n\t\treturn\n\t}\n\n\t// Otherwise, just continue as normal.\n\tnext(ctx)\n})\n</code></pre> <p>Error Details</p> <p>The <code>huma.ErrorDetail</code> struct can be used to provide more information about the error, such as the location of the error and the value which was seen.</p>"},{"location":"features/middleware/#operations","title":"Operations","text":"<p>You can also add router-agnostic middleware to individual operations by setting the <code>huma.Operation.Middlewares</code> field. This middleware will run after the router-specific middleware and before the operation handler.</p> code.go<pre><code>func MyMiddleware(ctx huma.Context, next func(huma.Context)) {\n\t// Call the next middleware in the chain. This eventually calls the\n\t// operation handler as well.\n\tnext(ctx)\n}\n\nfunc main() {\n\t// ...\n\tapi := humachi.New(router, config)\n\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"demo\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/demo\",\n\t\tMiddlewares: huma.Middlewares{MyMiddleware},\n\t}, func(ctx context.Context, input *MyInput) (*MyOutput, error) {\n\t\t// TODO: implement handler...\n\t\treturn nil, nil\n\t})\n}\n</code></pre> <p>It's also possible for global middleware to run only for certain paths by checking the request context's URL within the middleware, or by using something like the <code>huma.Operation.Metadata</code> to trigger the middleware logic using custom settings. It's up to you to decide how to structure your middleware and operations.</p>"},{"location":"features/middleware/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Context</code> a router-agnostic request/response context</li> <li><code>huma.Middlewares</code> list of middleware</li> <li><code>huma.ReadCookie</code> reads a named cookie from a request</li> <li><code>huma.ReadCookies</code> reads cookies from a request</li> <li><code>huma.WriteErr</code> function to write error responses</li> <li><code>huma.API</code> the API instance</li> </ul> </li> </ul>"},{"location":"features/model-validation/","title":"Model Validation","text":""},{"location":"features/model-validation/#model-validation_1","title":"Model Validation","text":"<p>Huma includes a utility to make it a little easier to validate models outside of the normal HTTP request/response flow, for example on app startup to load example or default data and verify it is correct. This is just a thin wrapper around the built-in validation functionality, but abstracts away some of the boilerplate required for efficient operation and provides a simple API.</p> code.go<pre><code>type MyExample struct {\n\tName string `json:\"name\" maxLength:\"5\"`\n\tAge int `json:\"age\" minimum:\"25\"`\n}\n\nvar value any\njson.Unmarshal([]byte(`{\"name\": \"abcdefg\", \"age\": 1}`), &amp;value)\n\nvalidator := huma.NewModelValidator()\nerrs := validator.Validate(reflect.TypeOf(MyExample{}), value)\nif errs != nil {\n\tfmt.Println(\"Validation error\", errs)\n}\n</code></pre> <p>Concurrency</p> <p>The <code>huma.ModelValidator</code> is not goroutine-safe! For more flexible validation, use the <code>huma.Validate</code> function directly and provide your own registry, path buffer, validation result struct, etc.</p>"},{"location":"features/model-validation/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.ModelValidator</code> the model validator utility</li> </ul> </li> <li>External Links<ul> <li>JSON Schema spec</li> <li>OpenAPI 3.1 spec</li> </ul> </li> <li>See Also<ul> <li>Config &amp; OpenAPI</li> </ul> </li> </ul>"},{"location":"features/openapi-generation/","title":"Configuration &amp; Open API","text":""},{"location":"features/openapi-generation/#configuration-open-api_1","title":"Configuration &amp; Open API","text":"<p>Huma generates Open API 3.1 compatible JSON/YAML specs and provides rendered documentation automatically. Every operation that is registered with the API is included in the spec by default. The operation's inputs and outputs are used to generate the request and response parameters / schemas.</p> <p>The <code>huma.Config</code> controls where the OpenAPI, docs, and schemas are available. The default config uses <code>/openapi</code>, <code>/docs</code>, and <code>/schemas</code> respectively. You can change these to whatever you want, or disable them entirely by leaving them blank. The OpenAPI spec is available in multiple versions (to better support older tools) and in JSON or YAML:</p> <ul> <li>OpenAPI 3.1 JSON: http://localhost:8888/openapi.json</li> <li>OpenAPI 3.1 YAML: http://localhost:8888/openapi.yaml</li> <li>OpenAPI 3.0.3 JSON: http://localhost:8888/openapi-3.0.json</li> <li>OpenAPI 3.0.3 YAML: http://localhost:8888/openapi-3.0.yaml</li> </ul> <p>You may want to customize the generated Open API spec. With Huma v2 you have full access and can modify it as needed in the API configuration or when registering operations. For example, to set up and then use a security scheme:</p> code.go<pre><code>config := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig.Components.SecuritySchemes = map[string]*huma.SecurityScheme{\n\t\t\"bearer\": {\n\t\t\tType: \"http\",\n\t\t\tScheme: \"bearer\",\n\t\t\tBearerFormat: \"JWT\",\n\t\t},\n\t}\napi := humachi.New(router, config)\n\nhuma.Register(api, huma.Operation{\n\tOperationID: \"get-greeting\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/greeting/{name}\",\n\tSummary:     \"Get a greeting\",\n\tSecurity: []map[string][]string{\n\t\t{\"bearer\": {}},\n\t},\n}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t// ...\n})\n</code></pre> <p>Spec</p> <p>See the OpenAPI 3.1 spec and Huma's OpenAPI struct for everything that can be set and how it is expected to be used.</p>"},{"location":"features/openapi-generation/#openapi-settings-composition","title":"OpenAPI Settings Composition","text":"<p>Because you have full access to the OpenAPI spec, you can compose it however you want and write convenience functions to make things more straightforward. The above example could be made easier to read:</p> code.go<pre><code>config := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig = withBearerAuthScheme(config)\n\napi := humachi.New(router, config)\n\nhuma.Register(api, withBearerAuth(huma.Operation{\n\tOperationID: \"get-greeting\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/greeting/{name}\",\n\tSummary:     \"Get a greeting\",\n}), func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t// ...\n})\n</code></pre> <p>Set this up however you like. Even the <code>huma.Register</code> function can be wrapped or replaced by your organization to ensure that all operations are registered with the same settings.</p>"},{"location":"features/openapi-generation/#custom-openapi-extensions","title":"Custom OpenAPI Extensions","text":"<p>Custom extensions to the OpenAPI are supported via the <code>Extensions</code> field on most OpenAPI structs:</p> code.go<pre><code>config := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig.Extensions = map[string]any{\n\t\"my-extension\": \"my-value\",\n}\n</code></pre> <p>Anything in the <code>Extensions</code> map will be flattened during serialization so that its fields are peers with the <code>Extensions</code> peers in the OpenAPI spec. For example, the above would result in:</p> openapi.json<pre><code>{\n\t\"openapi\": \"3.1.0\",\n\t\"info\": {\n\t\t\"title\": \"My API\",\n\t\t\"version\": \"1.0.0\"\n\t},\n\t\"my-extension\": \"my-value\"\n}\n</code></pre>"},{"location":"features/openapi-generation/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Tutorial<ul> <li>Your First API includes using the default config</li> </ul> </li> <li>Reference<ul> <li><code>huma.Config</code> the API config</li> <li><code>huma.DefaultConfig</code> the default API config</li> <li><code>huma.OpenAPI</code> the OpenAPI spec</li> <li><code>huma.API</code> the API instance</li> <li><code>huma.Register</code> registers new operations</li> </ul> </li> <li>External Links<ul> <li>OpenAPI 3.1 spec</li> </ul> </li> </ul>"},{"location":"features/operations/","title":"Operations","text":""},{"location":"features/operations/#operations_1","title":"Operations","text":"<p>Operations are at the core of Huma. They map an HTTP method verb and resource path to a handler function with well-defined inputs and outputs. When looking at an API made up of resources, the operations correspond to the <code>GET</code>, <code>POST</code>, <code>PUT</code>, etc methods on those resources like in the example below:</p> <pre><code>graph TD\n    subgraph Operations\n        GET\n        GET2[GET]\n        POST\n        PUT\n        DELETE\n    end\n\n    API --&gt; Resource1[Resource /items]\n    API --&gt; Resource2[\"Resource /users/{user-id}\"]\n\n    Resource1 --&gt; POST\n    Resource1 --&gt; GET\n    Resource1 --&gt; DELETE\n    Resource2 --&gt; GET2\n    Resource2 --&gt; PUT</code></pre> <p>Operations are created using the <code>huma.Register</code> function:</p> <pre><code>huma.Register(api, huma.Operation{\n\tOperationID: \"your-operation-name\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/path/to/resource/{id}\",\n\tSummary:     \"A short description of the operation\",\n}, func(ctx context.Context, input *YourInput) (*YourOutput, error) {\n\t// ... Implementation goes here ...\n})\n</code></pre> <p>REST</p> <p>If following REST-ish conventions, operation paths should be nouns, and plural if they return more than one item. Good examples: <code>/notes</code>, <code>/likes</code>, <code>/users/{user-id}</code>, <code>/videos/{video-id}/stats</code>, etc. Huma does not enforce this or care, so RPC-style paths are also fine to use. Use what works best for you and your team.</p> <p>OperationID</p> <p>Did you know? The <code>OperationID</code> is used to generate friendly CLI commands in Restish and used when generating SDKs! It should be unique, descriptive, and easy to type.</p> Terminal<pre><code>$ restish your-api your-operation-name --param=value ...\n</code></pre>"},{"location":"features/operations/#convenience-methods","title":"Convenience Methods","text":"<p>A number of convenience methods are provided if you don't want to use the <code>huma.Operation</code> struct directly. The following are available:</p> <ul> <li><code>huma.Get</code></li> <li><code>huma.Post</code></li> <li><code>huma.Put</code></li> <li><code>huma.Patch</code></li> <li><code>huma.Delete</code></li> </ul> <p>These methods are equivalent to using <code>huma.Register</code> with the <code>Method</code> field set to the corresponding HTTP method, and they generate the operation ID for you based on the path. For example:</p> code.go<pre><code>huma.Get(api, \"/things/{thing-id}\", func(ctx context.Context, input *YourInput) (*YourOutput, error) {\n    // ... Implementation goes here ...\n})\n</code></pre> <p>In the example above, the generated operation ID is <code>get-things-by-thing-id</code> with a summary of <code>Get things by id</code>. Note that any spaces in an operation ID will be automatically replaced with hyphens (e.g. <code>my operation</code> becomes <code>my-operation</code>) to ensure compatibility with various tools.</p> <p>To customize these, override <code>huma.GenerateOperationID(method, path string, response any)</code> for operation IDs and <code>huma.GenerateSummary(method, path string, response any)</code> for summaries.</p> <p>This makes it easy to get started, particularly if coming from other frameworks, and you can simply switch to using <code>huma.Register</code> if/when you need to set additional fields on the operation.</p>"},{"location":"features/operations/#handler-function","title":"Handler Function","text":"<p>The operation handler function always has the following generic format, where <code>Input</code> and <code>Output</code> are custom structs defined by the developer that represent the entirety of the request (path/query/header/cookie params &amp; body) and response (headers &amp; body), respectively:</p> code.go<pre><code>func(context.Context, *Input) (*Output, error)\n</code></pre> <p>There are many options available for configuring OpenAPI settings for the operation, and custom extensions are supported as well. See the <code>huma.Operation</code> struct for more details.</p>"},{"location":"features/operations/#input-output-models","title":"Input &amp; Output Models","text":"<p>Inputs and outputs are always structs that represent the entirety of the incoming request or outgoing response. This is a deliberate design decision to make it easier to reason about the data flow in your application. It also makes it easier to share code as well as generate documentation and SDKs.</p> <p>If your operation has no inputs or outputs, you can use a pointer to an empty struct <code>*struct{}</code> when registering it.</p> code.go<pre><code>func(ctx context.Context, input *struct{}) (*struct{}, error) {\n    // Successful response example, defaults to HTTP 204 No Content\n    return nil, nil\n}\n</code></pre>"},{"location":"features/operations/#request-flow","title":"Request Flow","text":"<p>A request flowing into the API goes through a number of steps before reaching your operation handler. The following diagram shows the flow of a request through the system, from request inputs like path/query/header parameters and the request body, through validation, the operation handler, and how outputs are sent in the response.</p> <pre><code>graph LR\n    subgraph Inputs\n        Path\n        Query\n        Header\n        Body\n        RawBody\n    end\n\n    subgraph Outputs\n        Status\n        Headers\n        OutBody[Body]\n    end\n\n    Path --&gt; Validate\n    Query --&gt; Validate\n    Header --&gt; Validate\n    Body --&gt; Unmarshal --&gt; Validate\n    Validate --&gt; Resolve --&gt; Operation\n    RawBody --&gt;|raw body input| Operation\n    Operation --&gt; Transform\n    Transform --&gt; Status\n    Transform --&gt; Headers\n    Transform --&gt; Marshal --&gt; OutBody\n    Operation --&gt;|raw body output| OutBody\n\n    style Operation stroke:#f9f,stroke-width:2px,stroke-dasharray: 5 5</code></pre> <code>Unmarshal</code> <p>Read the raw bytes of the request body (e.g. JSON) into a Go structure.</p> <code>Validate</code> <p>Check constraints on the inputs (e.g. <code>minimum</code>, <code>maxLength</code>, etc) and report failures.</p> <code>Resolve</code> <p>Run custom validation code and report failures.</p> <code>Operation</code> <p>Your operation handler function. Business logic goes here. It returns either your response structure or an error.</p> <code>Transform</code> <p>Modify the structured response data on the fly before marshaling it to bytes.</p> <code>Marshal</code> <p>Convert the structured response data into bytes (e.g. JSON).</p> <p>Read on to learn about how each of these steps works.</p>"},{"location":"features/operations/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Tutorial<ul> <li>Your First API includes registering an operation</li> </ul> </li> <li>Reference<ul> <li><code>huma.Register</code> registers new operations</li> <li><code>huma.Operation</code> the operation</li> </ul> </li> <li>External Links<ul> <li>OpenAPI 3.1 Operation Object</li> </ul> </li> </ul>"},{"location":"features/request-inputs/","title":"Request Inputs","text":""},{"location":"features/request-inputs/#parameters","title":"Parameters","text":"<p>Requests can have parameters and/or a body as input to the handler function. Inputs use standard Go structs with special fields and/or tags. Here are the available tags:</p> Tag Description Example <code>path</code> Name of the path parameter <code>path:\"thing-id\"</code> <code>query</code> Name of the query string parameter <code>query:\"q\"</code> <code>header</code> Name of the header parameter <code>header:\"Authorization\"</code> <code>cookie</code> Name of the cookie parameter <code>cookie:\"session\"</code> <code>required</code> Mark a cookie/header/query param as required <code>required:\"true\"</code> <p>Default Optionality</p> <p>Cookier, header, and query parameters are optional by default. Path parameters are always required. This differs from object fields (e.g. in a request body), which are required by default unless <code>omitempty</code> or <code>omitzero</code> is used.</p> <p>Required</p> <p>The <code>required</code> tag is discouraged and is only used for header/query params, which should generally be optional for clients to send.</p>"},{"location":"features/request-inputs/#parameter-types","title":"Parameter Types","text":"<p>The following parameter types are supported out of the box:</p> Type Example Inputs <code>bool</code> <code>true</code>, <code>false</code> <code>[u]int[16/32/64]</code> <code>1234</code>, <code>5</code>, <code>-1</code> <code>float32/64</code> <code>1.234</code>, <code>1.0</code> <code>string</code> <code>hello</code>, <code>t</code> <code>time.Time</code> <code>2020-01-01T12:00:00Z</code> slice, e.g. <code>[]int</code> <code>1,2,3</code>, <code>tag1,tag2</code> <p>For example, if the parameter is a query param and the type is <code>[]string</code> it might look like <code>?tags=tag1,tag2</code> in the URI. Query parameters also support specifying the same parameter multiple times by setting the <code>explode</code> tag, e.g. <code>query:\"tags,explode\"</code> would parse a query string like <code>?tags=tag1&amp;tags=tag2</code> instead of a comma separated list. The comma separated list is faster and recommended for most use cases.</p> <p>For cookies, the default behavior is to read the cookie value from the request and convert it to one of the types above. If you want to access the entire cookie, you can use <code>http.Cookie</code> as the type instead:</p> code.go<pre><code>type MyInput struct {\n\tSession http.Cookie `cookie:\"session\"`\n}\n</code></pre> <p>Then you can access e.g. <code>input.Session.Name</code> or <code>input.Session.Value</code>.</p>"},{"location":"features/request-inputs/#custom-wrapper-types","title":"Custom wrapper types","text":"<p>Request parameters can be parsed into custom wrapper types, by implementing the <code>ParamWrapper</code> interface, which should give access to the wrapper field as a <code>reflect.Value</code>.</p> <p>Interface <code>ParamReactor</code> may optionally be implemented to define a callback to execute after a request parameter was parsed.</p> <p>Example usage with a custom wrapper to handle null query parameters:</p> <pre><code>type OptionalParam[T any] struct {\n\tValue T\n\tIsSet bool\n}\n\n// Define schema to use wrapped type\nfunc (o OptionalParam[T]) Schema(r huma.Registry) *huma.Schema {\n\treturn huma.SchemaFromType(r, reflect.TypeOf(o.Value))\n}\n\n// Expose wrapped value to receive parsed value from Huma\n// MUST have pointer receiver\nfunc (o *OptionalParam[T]) Receiver() reflect.Value {\n\treturn reflect.ValueOf(o).Elem().Field(0)\n}\n\n// React to request param being parsed to update internal state\n// MUST have pointer receiver\nfunc (o *OptionalParam[T]) OnParamSet(isSet bool, parsed any) {\n\to.IsSet = isSet\n}\n\n// Define request input with the wrapper type\ntype MyRequestInput struct {\n    MaybeText OptionalParam[string] `query:\"text\"`\n}\n</code></pre>"},{"location":"features/request-inputs/#request-body","title":"Request Body","text":"<p>The special struct field <code>Body</code> will be treated as the input request body and can refer to any other type or you can embed a struct or slice inline. If the body is a pointer, then it is optional. All doc &amp; validation tags are allowed on the body in addition to these tags:</p> Tag Description Example <code>contentType</code> Override the content type <code>contentType:\"application/my-type+json\"</code> <code>nameHint</code> Hint for the schema name <code>nameHint:\"MyRequestBody\"</code> <code>required</code> Mark the body as required <code>required:\"true\"</code> <p><code>RawBody []byte</code> can also be used alongside <code>Body</code> to provide access to the <code>[]byte</code> used to validate &amp; parse <code>Body</code>.</p>"},{"location":"features/request-inputs/#special-types","title":"Special Types","text":"<p>The following special types are supported out of the box:</p> Type Schema Example <code>time.Time</code> <code>{\"type\": \"string\", \"format\": \"date-time\"}</code> <code>\"2020-01-01T12:00:00Z\"</code> <code>url.URL</code> <code>{\"type\": \"string\", \"format\": \"uri\"}</code> <code>\"https://example.com\"</code> <code>net.IP</code> <code>{\"type\": \"string\", \"format\": \"ipv4\"}</code> <code>\"127.0.0.1\"</code> <code>netip.Addr</code> <code>{\"type\": \"string\", \"format\": \"ip\"}</code> <code>\"127.0.0.1\"</code> or <code>fe80::1</code> <code>json.RawMessage</code> <code>{}</code> <code>[\"whatever\", \"you\", \"want\"]</code> <p>You can override this default behavior if needed as described in Schema Customization and Request Validation, e.g. setting a custom <code>format</code> tag for IPv6.</p>"},{"location":"features/request-inputs/#other-body-types","title":"Other Body Types","text":"<p>Sometimes, you want to bypass the normal body parsing and instead read the raw body contents directly. This is useful for unstructured data, file uploads, or other binary data. You can use <code>RawBody []byte</code> without a <code>Body</code> field to access the raw body bytes without any parsing/validation being applied. For example, to accept some <code>text/plain</code> input:</p> code.go<pre><code>huma.Register(api, huma.Operation{\n\tOperationID: \"post-plain-text\",\n\tMethod:      http.MethodPost,\n\tPath:        \"/text\",\n\tSummary:     \"Example to post plain text input\",\n}, func(ctx context.Context, input *struct {\n\tRawBody []byte `contentType:\"text/plain\"`\n}) (*struct{}, error) {\n\tfmt.Println(\"Got input:\", input.RawBody)\n\treturn nil, nil\n}\n</code></pre> <p>This enables you to also do your own parsing of the input, if needed.</p>"},{"location":"features/request-inputs/#multipart-form-data","title":"Multipart Form Data","text":"<p>Multipart form data is supported by using a <code>RawBody</code> with a type of <code>multipart.Form</code> in the input struct. This will parse the request using Go standard library multipart processing implementation.</p> <p>For example:</p> multipart.go<pre><code>huma.Register(api, huma.Operation{\n\tOperationID: \"upload-files\",\n    Method:      http.MethodPost,\n    Path:        \"/upload\",\n    Summary:     \"Example to upload a file\",\n}, func(ctx context.Context, input *struct {\n    RawBody multipart.Form\n}) (*struct{}, error) {\n    // Process multipart form here.\n\tfor name, _ := range input.RawBody.File {\n\t    fmt.Printf(\"Obtained file with name '%s'\", name)\n\t}\n\tfor name, val := range input.RawBody.Value {\n\t    fmt.Printf(\"Obtained value with name '%s' and value '%s'\", name, val)\n\t}\n    return nil, nil\n})\n</code></pre> <p>This will be useful for supporting file uploads. Moreover, Huma can process files and values from the multipart form into a struct for you. In this case, you should define what the processed struct should look like:</p> multipart_form_files.go<pre><code>huma.Register(api, huma.Operation{\n\tOperationID: \"upload-and-decode-files\"\n\tMethod:      http.MethodPost,\n\tPath:        \"/upload\",\n}, func(ctx context.Context, input *struct {\n\tRawBody huma.MultipartFormFiles[struct {\n\t\tMyFile                    huma.FormFile   `form:\"file\" contentType:\"text/plain\" required:\"true\"`\n\t\tSomeOtherFiles            []huma.FormFile `form:\"other-files\" contentType:\"text/plain\" required:\"true\"`\n\t\tNoTagBindingFile          huma.FormFile   `contentType:\"text/plain\"`\n\t\tMyGreeting                string          `form:\"greeting\", minLength:\"6\"`\n\t\tSomeNumbers               []int           `form:\"numbers\"`\n\t\tNonTaggedValuesAreIgnored string  // ignored\n\t}]\n}) (*struct{}, error) {\n\t// The raw multipart.Form body is again available under input.RawBody.Form.\n\t// E.g. input.RawBody.Form.File(\"file\")\n\t// E.g. input.RawBody.Form.Value(\"greeting\")\n\n\t// The processed input struct is available under input.RawBody.Data().\n\tformData := input.RawBody.Data()\n\n\t// Non-files are available and validated if they have a \"form\" tag\n\tfmt.Println(formData.MyGreeting)\n\tfmt.Println(\"These are your numbers:\")\n\tfor _, n := range formData.SomeNumbers {\n\t\tfmt.Println(n)\n\t}\n\n\t// Non-files without \"form\" tag are not available\n\tif formData.NonTaggedValuesAreIgnored != nil {\n\t\tpanic(\"This should not happen\")\n\t}\n\n\t// Process files here.\n\tb, err := io.ReadAll(formData.MyFile)\n\tfmt.Println(string(b))\n\n\tfor _, f := range formData.SomeOtherFiles {\n\t\tb, err := io.ReadAll(f)\n\t\tfmt.Println(string(b))\n\t}\n\n\t// Flag for checking optional file existence.\n\tif formData.NoTagBindingFile.IsSet {\n\t\tfmt.Println(\"The form contained a file entry with name 'NoTagBinding'!\")\n\t}\n\treturn nil, nil\n})\n</code></pre> <p>The files are decoded according to the specified contentType. If no contentType is provided, it defaults to <code>application/octet-stream</code>.</p>"},{"location":"features/request-inputs/#request-example","title":"Request Example","text":"<p>Here is an example request input struct, which has a path param, query param, header param, and a structured body alongside the raw body bytes:</p> code.go<pre><code>type MyInput struct {\n\tID      string `path:\"id\"`\n\tDetail  bool   `query:\"detail\" doc:\"Show full details\"`\n\tAuth    string `header:\"Authorization\"`\n\tBody    MyBody\n\tRawBody []byte\n}\n</code></pre> <p>A request to such an endpoint might look like:</p> Terminal<pre><code># Via high-level operations:\n$ restish api my-op 123 --detail=true --authorization=foo &lt;body.json\n\n# Via URL:\n$ restish api/my-op/123?detail=true -H \"Authorization: foo\" &lt;body.json\n</code></pre> <p>Uploads</p> <p>You can use <code>RawBody []byte</code> without a corresponding <code>Body</code> field in order to support small file uploads.</p>"},{"location":"features/request-inputs/#input-composition","title":"Input Composition","text":"<p>Because inputs are just Go structs, they are composable and reusable. For example:</p> code.go<pre><code>type AuthParam struct {\n\tAuthorization string `header:\"Authorization\"`\n}\n\ntype PaginationParams struct {\n\tCursor string `query:\"cursor\"`\n\tLimit  int    `query:\"limit\"`\n}\n\n// ... Later in the code\nhuma.Register(api, huma.Operation{\n\tOperationID: \"list-things\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/things\",\n\tSummary:     \"Get a filtered list of things\",\n}, func(ctx context.Context, input *struct {\n\t// Embed both structs to compose your input.\n\tAuthParam\n\tPaginationParams\n}) (*struct{}, error) {\n\tfmt.Printf(\"Auth: %s, Cursor: %s, Limit: %d\\n\", input.Authorization, input.Cursor, input.Limit)\n\treturn nil, nil\n}\n</code></pre>"},{"location":"features/request-inputs/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Tutorial<ul> <li>Your First API includes registering an operation with a path param</li> </ul> </li> <li>Reference<ul> <li><code>huma.Register</code> registers new operations</li> <li><code>huma.Operation</code> the operation</li> </ul> </li> <li>External Links<ul> <li>OpenAPI 3.1 Operation Object</li> <li>OpenAPI 3.1 Parameter Object</li> </ul> </li> </ul>"},{"location":"features/request-limits/","title":"Request Limits","text":""},{"location":"features/request-limits/#deadlines-timeouts","title":"Deadlines &amp; Timeouts","text":"<p>A combination of the server and the request context can be used to control deadlines &amp; timeouts. Go's built-in HTTP server supports a few timeout settings:</p> code.go<pre><code>srv := &amp;http.Server{\n\tReadTimeout:       5 * time.Second,\n\tWriteTimeout:      5 * time.Second,\n\tIdleTimeout:       30 * time.Second,\n\tReadHeaderTimeout: 2 * time.Second,\n\t// ...\n}\n</code></pre> <p>The Huma request context (accessible via resolvers) can be used to set a read deadline, which can be used to process large or streaming inputs:</p> code.go<pre><code>type MyInput struct {}\n\nfunc (m *MyInput) Resolve(ctx huma.Context) []error {\n\tctx.SetReadDeadline(time.Now().Add(5 * time.Second))\n}\n</code></pre> <p>Additionally, a <code>context.Context</code> can be used to set a deadline for dependencies like databases:</p> code.go<pre><code>// Create a new context with a 10 second timeout.\nnewCtx, cancel := context.WithTimeout(ctx, 10 * time.Second)\ndefer cancel()\n\n// Use the new context for any dependencies.\nresult, err := myDB.Get(newCtx, /* ... */)\nif err != nil {\n\t// Deadline may have been hit, handle it here!\n}\n</code></pre>"},{"location":"features/request-limits/#body-size-limits","title":"Body Size Limits","text":"<p>By default each operation has a 1 MiB request body size limit. This can be changed by setting <code>huma.Operation.MaxBodyBytes</code> to a different value when registering the operation. If the request body is larger than the limit then a <code>413 Request Entity Too Large</code> error will be returned.</p> code.go<pre><code>huma.Register(api, huma.Operation{\n\tOperationID:  \"put-thing\",\n\tMethod:       http.MethodPut,\n\tPath:         \"/things/{thing-id}\",\n\tSummary:      \"Put a thing by ID\",\n\tMaxBodyBytes: 10 * 1024 * 1024, // 10 MiB\n}, func(ctx context.Context, input ThingRequest) (*struct{}, error) {\n\t// Do nothing...\n\treturn nil, nil\n}\n</code></pre> <p>Keep in mind that the body is read into memory before being passed to the handler function.</p>"},{"location":"features/request-limits/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Resolver</code> is the basic interface</li> <li><code>huma.ResolverWithPath</code> has a path prefix</li> <li><code>huma.Operation</code> the operation</li> <li><code>huma.Context</code> a router-agnostic request/response context</li> </ul> </li> <li>External Links<ul> <li>Go Contexts from the Go blog</li> <li><code>context.Context</code></li> <li><code>http.Server</code></li> </ul> </li> </ul>"},{"location":"features/request-resolvers/","title":"Request Resolvers","text":""},{"location":"features/request-resolvers/#request-resolvers_1","title":"Request Resolvers","text":"<p>Sometimes the built-in validation isn't sufficient for your use-case, or you want to do something more complex with the incoming request object. This is where resolvers come in.</p> <p>Any input struct can be a resolver by implementing the <code>huma.Resolver</code> or <code>huma.ResolverWithPath</code> interface, including embedded structs. Each resolver takes the current context and can return a list of exhaustive errors. For example:</p> code.go<pre><code>// MyInput demonstrates inputs/transformation\ntype MyInput struct {\n\tHost   string\n\tName string `query:\"name\"`\n}\n\nfunc (m *MyInput) Resolve(ctx huma.Context) []error {\n\t// Get request info you don't normally have access to.\n\tm.Host = ctx.Host()\n\n\t// Transformations or other data validation\n\tm.Name = strings.Title(m.Name)\n\n\treturn nil\n}\n\n// Then use it like any other input struct:\nhuma.Register(api, huma.Operation{\n\tOperationID: \"list-things\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/things\",\n\tSummary:     \"Get a filtered list of things\",\n}, func(ctx context.Context, input *MyInput) (*YourOutput, error) {\n\tfmt.Printf(\"Host: %s\\n\", input.Host)\n\tfmt.Printf(\"Name: %s\\n\", input.Name)\n})\n</code></pre> <p>It is recommended that you do not save the context object passed to the <code>Resolve</code> method for later use.</p> <p>For deeply nested structs within the request body, you may not know the current location of the field being validated (e.g. it may appear in multiple places or be shared by multiple request objects). The <code>huma.ResolverWithPath</code> interface provides a path prefix that can be used to generate the full path to the field being validated. It uses a <code>huma.PathBuffer</code> for efficient path generation reusing a shared buffer. For example:</p> code.go<pre><code>func (m *MyInput) Resolve(ctx huma.Context, prefix *huma.PathBuffer) []error {\n\treturn []error{&amp;huma.ErrorDetail{\n\t\tMessage: \"Foo has a bad value\",\n\t\tLocation: prefix.With(\"foo\"),\n\t\tValue: m.Foo,\n\t}}\n}\n</code></pre> <p>Validation Preference</p> <p>Prefer using built-in validation over resolvers whenever possible, as it will be better documented and is also usable by OpenAPI tooling to provide a better developer experience.</p>"},{"location":"features/request-resolvers/#resolver-errors","title":"Resolver Errors","text":"<p>Resolvers can set errors as needed and Huma will automatically return a 400-level error response before calling your handler. This makes resolvers a good place to run additional complex validation steps so you can provide the user with a set of exhaustive errors.</p> code.go<pre><code>type MyInput struct {\n\tHost   string\n}\n\nfunc (m *MyInput) Resolve(ctx huma.Context) []error {\n\tm.Host = ctx.Host()\n\tif m.Host == \"localhost\" {\n\t\treturn []error{&amp;huma.ErrorDetail{\n\t\t\tMessage: \"Unsupported host value!\",\n\t\t\tLocation: \"request.host\",\n\t\t\tValue: m.Host,\n\t\t}}\n\t}\n\treturn nil\n}\n</code></pre> <p>It is also possible for resolvers to return custom HTTP status codes for the response, by returning an error which satisfies the <code>huma.StatusError</code> interface. Errors are processed in the order they are returned and the last one wins, so this feature should be used sparingly. For example:</p> code.go<pre><code>type MyInput struct{}\n\nfunc (i *MyInput) Resolve(ctx huma.Context) []error {\n\treturn []error{huma.Error403Forbidden(\"nope\")}\n}\n</code></pre> <p>Why Exhaustive Errors?</p> <p>Exhaustive errors lessen frustration for users. It's better to return three errors in response to one request than to have the user make three requests which each return a new different error.</p>"},{"location":"features/request-resolvers/#unwrapping","title":"Unwrapping","text":"<p>While generally not recommended, if you need to access the underlying router-specific request and response objects, you can <code>Unwrap()</code> them using the router-specific adapter package you used to create the API instance. See the middleware documentation for more information.</p>"},{"location":"features/request-resolvers/#implementation-check","title":"Implementation Check","text":"<p>There is a Go trick for ensuring that a struct implements a certain interface, and you can utilize it to ensure your resolvers will be called as expected. For example:</p> code.go<pre><code>// Ensure MyInput implements huma.Resolver\nvar _ huma.Resolver = (*MyInput)(nil)\n</code></pre> <p>This creates a new <code>nil</code> pointer to your struct and assigns it to an unnamed variable of type <code>huma.Resolver</code>. It will be compiled and then thrown away during optimization. If your resolver code changes and no longer implements the interface, the code will fail to compile.</p>"},{"location":"features/request-resolvers/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>How-To<ul> <li>Custom Validation includes using resolvers</li> </ul> </li> <li>Reference<ul> <li><code>huma.Resolver</code> is the basic interface</li> <li><code>huma.ResolverWithPath</code> has a path prefix</li> <li><code>huma.Context</code> a router-agnostic request/response context</li> </ul> </li> </ul>"},{"location":"features/request-validation/","title":"Request Validation","text":""},{"location":"features/request-validation/#request-validation_1","title":"Request Validation","text":"<p>Go struct tags are used to annotate inputs/output structs with information that gets turned into JSON Schema for documentation and validation. For example:</p> code.go<pre><code>type Person struct {\n    Name string `json:\"name\" doc:\"Person's name\" minLength:\"1\" maxLength:\"80\"`\n    Age  uint   `json:\"age,omitempty\" doc:\"Person's age\" maximum:\"120\"`\n}\n</code></pre>"},{"location":"features/request-validation/#field-naming","title":"Field Naming","text":"<p>The standard <code>json</code> tag is supported and can be used to rename a field. Any field tagged with <code>json:\"-\"</code> will be ignored in the schema, as if it did not exist.</p>"},{"location":"features/request-validation/#optional-required","title":"Optional / Required","text":"<p>Fields being optional/required is determined automatically but can be overridden as needed using the logic below:</p> <ol> <li>Start with all fields required, except for cookie, header, and query parameters which are optional by default.<ul> <li>If <code>huma.Config.FieldsOptionalByDefault</code> is set to <code>true</code>, then all fields are optional by default.</li> </ul> </li> <li>If a field has <code>omitempty</code>, it is optional.</li> <li>If a field has <code>omitzero</code>, it is optional.</li> <li>If a field has <code>required:\"false\"</code>, it is optional.</li> <li>If a field has <code>required:\"true\"</code>, it is required.</li> </ol> <p>Path parameters are always required. Cookie, header, and query parameters are optional unless explicitly marked with <code>required:\"true\"</code>. All other fields (like those in a request body or multipart form) follow the default required status.</p> <p>Pointers have no effect on optional/required. The same rules apply regardless of whether the struct is being used for request input or response output. Some examples:</p> <pre><code>type MyStruct struct {\n    // The following are all required by default.\n    Required1 string  `json:\"required1\"`\n    Required2 *string `json:\"required2\"`\n    Required3 string  `json:\"required3,omitempty\" required:\"true\"`\n\n    // The following are all optional.\n    Optional1 string  `json:\"optional1,omitempty\"`\n    Optional2 string  `json:\"optional2,omitzero\"`\n    Optional3 *string `json:\"optional3,omitempty\"`\n    Optional4 *string `json:\"optional4,omitempty,omitzero\"`\n    Optional5 string  `json:\"optional5\" required:\"false\"`\n}\n</code></pre> <p>If you prefer all fields to be optional by default, you can set <code>FieldsOptionalByDefault</code> in the <code>huma.Config</code>:</p> <pre><code>config := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig.FieldsOptionalByDefault = true\n</code></pre> <p>With this setting, <code>Required1</code> and <code>Required2</code> in the example above would become optional. <code>Required3</code> would remain required.</p> <p>Note</p> <p>Why use <code>omitempty</code> for inputs when Go itself only uses the field for marshaling? Imagine a client which is going to send a request to your API - it must still be marshaled into JSON (or a similar format). You can think of your input structs as modeling what an API client would produce as output.</p>"},{"location":"features/request-validation/#nullable","title":"Nullable","text":"<p>In many languages (including Go), there is little to no distinction between an explicit empty value vs. an undefined one. Marking a field as optional as explained above is enough to support either case. Javascript &amp; Typescript are exceptions to this rule, as they have explicit <code>null</code> and <code>undefined</code> values.</p> <p>Huma tries to balance schema simplicity, usability, and broad compatibility with schema correctness and a broad range of language support for end-to-end API tooling. To that end, it supports field nullability to a limited extent, and future changes may modify this default behavior as tools become more compatible with advanced JSON Schema features.</p> <p>Fields being nullable is determined automatically but can be overridden as needed using the logic below:</p> <ol> <li>Start with no fields as nullable</li> <li>If a field is a pointer (including slices):<ol> <li>To a <code>boolean</code>, <code>integer</code>, <code>number</code>, <code>string</code>: it is nullable unless it has <code>omitempty</code>.</li> <li>To an <code>array</code>: it is nullable if <code>huma.DefaultArrayNullable</code> is true.</li> <li>To an <code>object</code>: it is not nullable, due to complexity and bad support for <code>anyOf</code>/<code>oneOf</code> in many tools.</li> </ol> </li> <li>If a field has <code>nullable:\"false\"</code>, it is not nullable</li> <li>If a field has <code>nullable:\"true\"</code>:<ol> <li>To a <code>boolean</code>, <code>integer</code>, <code>number</code>, <code>string</code>, <code>array</code>: it is nullable</li> <li>To an <code>object</code>: panic saying this is not currently supported</li> </ol> </li> <li>If a struct has a field <code>_</code> with <code>nullable: true</code>, the struct is nullable enabling users to opt-in for <code>object</code> without the <code>anyOf</code>/<code>oneOf</code> complication.</li> </ol> <p>Here are some examples:</p> code.go<pre><code>// Make an entire struct (not its fields) nullable.\ntype MyStruct1 struct {\n    _ struct{} `nullable:\"true\"`\n    Field1 string `json:\"field1\"`\n    Field2 string `json:\"field2\"`\n}\n\n// Make a specific scalar field nullable. This is *not* supported for\n// maps or structs. Structs *must* use the method above.\ntype MyStruct2 struct {\n    Field1 *string `json:\"field1\"`\n    Field2 string `json:\"field2\" nullable:\"true\"`\n}\n</code></pre> <p>Nullable types will generate a type array like <code>\"type\": [\"string\", \"null\"]</code> which has broad compatibility and is easy to downgrade to OpenAPI 3.0. Also keep in mind you can always provide a custom schema if the built-in features aren't exactly what you need.</p> <p>Note</p> <p>Slices in Go marshal into JSON as <code>null</code> if the slice itself is <code>nil</code> rather than allocated but empty. This is why slices are nullable by default. See the Go JSON package documentation for more information.</p>"},{"location":"features/request-validation/#validation-tags","title":"Validation Tags","text":"<p>The following additional tags are supported on model fields:</p> Tag Description Example <code>doc</code> Describe the field <code>doc:\"Who to greet\"</code> <code>format</code> Format hint for the field <code>format:\"date-time\"</code> <code>enum</code> A comma-separated list of possible values <code>enum:\"one,two,three\"</code> <code>default</code> Default value <code>default:\"123\"</code> <code>minimum</code> Minimum (inclusive) <code>minimum:\"1\"</code> <code>exclusiveMinimum</code> Minimum (exclusive) <code>exclusiveMinimum:\"0\"</code> <code>maximum</code> Maximum (inclusive) <code>maximum:\"255\"</code> <code>exclusiveMaximum</code> Maximum (exclusive) <code>exclusiveMaximum:\"100\"</code> <code>multipleOf</code> Value must be a multiple of this value <code>multipleOf:\"2\"</code> <code>minLength</code> Minimum string length <code>minLength:\"1\"</code> <code>maxLength</code> Maximum string length <code>maxLength:\"80\"</code> <code>pattern</code> Regular expression pattern <code>pattern:\"[a-z]+\"</code> <code>patternDescription</code> Description of the pattern used for errors <code>patternDescription:\"alphanum\"</code> <code>minItems</code> Minimum number of array items <code>minItems:\"1\"</code> <code>maxItems</code> Maximum number of array items <code>maxItems:\"20\"</code> <code>uniqueItems</code> Array items must be unique <code>uniqueItems:\"true\"</code> <code>minProperties</code> Minimum number of object properties <code>minProperties:\"1\"</code> <code>maxProperties</code> Maximum number of object properties <code>maxProperties:\"20\"</code> <code>example</code> Example value <code>example:\"123\"</code> <code>readOnly</code> Sent in the response only <code>readOnly:\"true\"</code> <code>writeOnly</code> Sent in the request only <code>writeOnly:\"true\"</code> <code>deprecated</code> This field is deprecated <code>deprecated:\"true\"</code> <code>hidden</code> Hide field/param from documentation <code>hidden:\"true\"</code> <code>dependentRequired</code> Required fields when the field is present <code>dependentRequired:\"one,two\"</code> <p>Built-in string formats include:</p> Format Description Example <code>date-time</code> Date and time in RFC3339 format <code>2021-12-31T23:59:59Z</code> <code>date-time-http</code> Date and time in HTTP format <code>Fri, 31 Dec 2021 23:59:59 GMT</code> <code>date</code> Date in RFC3339 format <code>2021-12-31</code> <code>time</code> Time in RFC3339 format <code>23:59:59</code> <code>duration</code> Duration <code>1h30m</code> <code>email</code> / <code>idn-email</code> Email address <code>kari@example.com</code> <code>hostname</code> Hostname <code>example.com</code> <code>ip</code> IPv4 or IPv6 address <code>127.0.0.1</code> or <code>::1</code> <code>ipv4</code> IPv4 address <code>127.0.0.1</code> <code>ipv6</code> IPv6 address <code>::1</code> <code>uri</code> / <code>iri</code> URI <code>https://example.com</code> <code>uri-reference</code> / <code>iri-reference</code> URI reference <code>/path/to/resource</code> <code>uri-template</code> URI template <code>/path/{id}</code> <code>json-pointer</code> JSON Pointer <code>/path/to/field</code> <code>relative-json-pointer</code> Relative JSON Pointer <code>0/1</code> <code>regex</code> Regular expression <code>[a-z]+</code> <code>uuid</code> UUID <code>550e8400-e29b-41d4-a716-446655440000</code>"},{"location":"features/request-validation/#defaults","title":"Defaults","text":"<p>The <code>default</code> field validation tag listed above is used to both document the existence of a server-side default value as well as to automatically have Huma set that value for you. This is useful for fields that are optional but have a default value if not provided.</p> <p>Similar to how the standard library JSON unmarshaler works, it is recommended to use pointers for scalar types where the zero value has semantic meaning to your application. For example, if you have a <code>bool</code> field that defaults to <code>true</code>, you should use a <code>*bool</code> field and set the default to <code>true</code>. This way, if the field is not provided, the default value will be used.</p> code.go<pre><code>type MyInput struct {\n\tBody struct {\n\t\tEnabled *bool `json:\"enabled\" default:\"true\"`\n\t}\n}\n</code></pre> <p>If you had used <code>bool</code> instead of <code>*bool</code> then the zero value of <code>false</code> would get overridden by the default value of <code>true</code>, even if false is explicitly sent by the client.</p>"},{"location":"features/request-validation/#read-and-write-only","title":"Read and Write Only","text":"<p>Note that the <code>readOnly</code> and <code>writeOnly</code> validations are not enforced by Huma and the values in those fields are not modified by Huma. They are purely for documentation purposes and allow you to re-use structs for both inputs and outputs.</p> <p>You will need to take care to ensure read-only fields are not modified. It's up to you whether you wish to ignore the field's value, compare it to an existing value in e.g. a datastore, or take some other action. This is a design choice to enable easier round-trips of data, for example reading a <code>GET</code> response with a read-only created date, modifying a different field, and sending it back to the server via <code>PUT</code>. The server should ignore both the presence and value of the created date, otherwise clients have to make potentially many modifications before data can be sent back to the server.</p> <p>Write-only fields, if stored in a datastore, can be combined with <code>omitempty</code> and then set to the zero value in handlers, or filtered out via datastore queries or projection. They can also be kept out of the datastore altogether but used to compute values in fields that will get stored.</p> <p>Note</p> <p>If a write-only field needs to be required on the request but the same struct is re-used in the response, you can use <code>json:\"name,omitempty\"</code> with <code>required:\"true\"</code>.</p>"},{"location":"features/request-validation/#strict-vs-loose-field-validation","title":"Strict vs. Loose Field Validation","text":"<p>By default, Huma is strict about which fields are allowed in an object, making use of the <code>additionalProperties: false</code> JSON Schema setting. This means if a client sends a field that is not defined in the schema, the request will be rejected with an error. This can help to prevent typos and other issues and is recommended for most APIs.</p> <p>The default behavior can be changed globally by setting <code>AllowAdditionalPropertiesByDefault</code> in the <code>huma.Config</code>'s <code>RegistryConfig</code>:</p> <pre><code>config := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig.AllowAdditionalPropertiesByDefault = true\n</code></pre> <p>If you need to allow additional fields on a per-struct basis, for example when using a third-party service which will call your system and you only care about a few fields, you can use the <code>additionalProperties:\"true\"</code> field tag on the struct by assigning it to a dummy <code>_</code> field.</p> code.go<pre><code>type PartialInput struct {\n\t_      struct{} `json:\"-\" additionalProperties:\"true\"`\n\tField1 string   `json:\"field1\"`\n\tField2 bool     `json:\"field2\"`\n}\n</code></pre> <p>Note</p> <p>The use of <code>struct{}</code> is optional but efficient. It is used to avoid allocating memory for the dummy field as an empty object requires no space.</p>"},{"location":"features/request-validation/#unknown-query-parameters","title":"Unknown Query Parameters","text":"<p>By default, unknown query parameters are ignored. You can set <code>RejectUnknownQueryParameters</code> to <code>true</code> in your <code>huma.Config</code> or for a specific <code>huma.Operation</code> to change this.</p> config.go<pre><code>config := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig.RejectUnknownQueryParameters = true\n</code></pre> <p>Or for a specific operation:</p> operation.go<pre><code>huma.Register(api, huma.Operation{\n    Method: http.MethodGet,\n    Path: \"/test\",\n    RejectUnknownQueryParameters: true,\n}, func(ctx context.Context, input *struct{}) (*struct{}, error) {\n    // ...\n})\n</code></pre> <p>When enabled, any query parameter sent by the client that is not defined in the input struct will result in a <code>422 Unprocessable Entity</code> error. This behavior is skipped if <code>SkipValidateParams</code> is set to <code>true</code> on the operation.</p>"},{"location":"features/request-validation/#advanced-validation","title":"Advanced Validation","text":"<p>When using custom JSON Schemas, i.e. not generated from Go structs, it's possible to utilize a few more validation rules. The following schema fields are respected by the built-in validator:</p> <ul> <li><code>not</code> for negation</li> <li><code>oneOf</code> for exclusive inputs</li> <li><code>anyOf</code> for matching one-or-more</li> <li><code>allOf</code> for schema unions</li> </ul> <p>See <code>huma.Schema</code> for more information. Note that it may be easier to use a custom resolver to implement some of these rules.</p>"},{"location":"features/request-validation/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Tutorial<ul> <li>Your First API includes string length validation</li> </ul> </li> <li>Reference<ul> <li><code>huma.Register</code> registers new operations</li> <li><code>huma.Operation</code> the operation</li> </ul> </li> <li>External Links<ul> <li>JSON Schema Validation</li> <li>OpenAPI 3.1 Schema Object</li> <li>OpenAPI 3.1 Operation Object</li> </ul> </li> </ul>"},{"location":"features/response-errors/","title":"Response Errors","text":""},{"location":"features/response-errors/#returning-http-errors","title":"Returning HTTP Errors","text":"<p>Handler functions can return errors instead of a successful response. There are a number of utility functions to return common HTTP errors:</p> code.go<pre><code>huma.Register(api, huma.Operation{\n\t\tOperationID: \"get-thing\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/things/{thing-id}\",\n\t\tSummary:     \"Get a thing by ID\",\n}, func(ctx context.Context, input ThingRequest) (*struct{}, error) {\n\t\t// Return a 404 Not Found error\n\t\treturn nil, huma.Error404NotFound(\"thing not found\")\n}\n</code></pre> <p>The error functions are named like <code>Error{code}{name}</code> and accept a message and error details which can provide more information back to the user. For example, <code>huma.Error400BadRequest(msg string, errs ...error)</code>. Editors like VSCode should automatically show the available errors as you type:</p> <p></p> <p>Default Error Response</p> <p>If the error returned has no associated HTTP status code, for example you use <code>fmt.Errorf(\"my error\")</code>, then the default error response code is <code>500 Internal Server Error</code>. Use <code>huma.NewError</code> to return an error with a custom status code.</p>"},{"location":"features/response-errors/#error-model","title":"Error Model","text":"<p>Errors use RFC 9457 Problem Details for HTTP APIs with a content type like <code>application/problem+json</code> and return a structure that looks like:</p> HTTP Response<pre><code>HTTP/2.0 422 Unprocessable Entity\nCache-Control: private\nContent-Length: 241\nContent-Type: application/problem+json\nLink: &lt;/schemas/ErrorModel.json&gt;; rel=\"describedBy\"\n\n{\n  \"$schema\": \"https://api.rest.sh/schemas/ErrorModel.json\",\n  \"status\": 422,\n  \"title\": \"Unprocessable Entity\",\n  \"detail\": \"validation failed\",\n  \"errors\": [\n    {\n      \"location\": \"body.title\",\n      \"message\": \"expected string\",\n      \"value\": true\n    },\n    {\n      \"location\": \"body.reviews\",\n      \"message\": \"unexpected property\",\n      \"value\": {\n        \"reviews\": 5,\n        \"title\": true\n      }\n    }\n  ]\n}\n</code></pre> <p>The <code>errors</code> field is optional and may contain more details about which specific errors occurred. See <code>huma.ErrorModel</code> for more details.</p> <p>To display a <code>location</code>, <code>message</code>, and <code>value</code> in the errors array, use the <code>huma.ErrorDetail</code> struct. If you need to wrap this with custom logic for any reason, you can implement the <code>huma.ErrorDetailer</code> interface.</p>"},{"location":"features/response-errors/#exhaustive-errors","title":"Exhaustive Errors","text":"<p>It is recommended to return exhaustive errors whenever possible to prevent user frustration with having to keep retrying a bad request and getting back a different error.</p> <p>Input parameters validation, body validation, resolvers, etc all support returning exhaustive errors. Because of this, it's preferable to use them over custom error logic in your operation handler.</p>"},{"location":"features/response-errors/#error-status-codes","title":"Error Status Codes","text":"<p>While every attempt is made to return exhaustive errors within Huma, each individual response can only contain a single HTTP status code. The following chart describes which codes get returned and when:</p> <pre><code>flowchart TD\n\tRequest[Request has errors?] --&gt;|yes| Panic\n\tRequest --&gt;|no| Continue[Continue to handler]\n\tPanic[Panic?] --&gt;|yes| 500\n\tPanic --&gt;|no| RequestBody[Request body too large?]\n\tRequestBody --&gt;|yes| 413\n\tRequestBody --&gt;|no| RequestTimeout[Request took too long to read?]\n\tRequestTimeout --&gt;|yes| 408\n\tRequestTimeout --&gt;|no| ParseFailure[Cannot parse input?]\n\tParseFailure --&gt;|yes| 400\n\tParseFailure --&gt;|no| ValidationFailure[Validation failed?]\n\tValidationFailure --&gt;|yes| 422\n\tValidationFailure --&gt;|no| 400</code></pre> <p>This means it is possible to, for example, get an HTTP <code>408 Request Timeout</code> response that also contains an error detail with a validation error for one of the input headers. Since request timeout has higher priority, that will be the response status code that is returned.</p>"},{"location":"features/response-errors/#error-headers","title":"Error Headers","text":"<p>Middleware can be used to add headers to all responses, e.g. for cache control, rate limiting, etc. For headers specific to errors or specific handler error responses, you can wrap the error with additional headers as needed:</p> code.go<pre><code>return nil, huma.ErrorWithHeaders(\n\thuma.Error404NotFound(\"thing not found\"),\n\thttp.Header{\n\t\t\"Cache-Control\": {\"no-store\"},\n\t},\n)\n</code></pre> <p>It is safe to call <code>huma.ErrorWithHeaders</code> multiple times, and all the passed headers will be appended to any existing ones.</p> <p>Any error which satisfies the <code>huma.HeadersError</code> interface will have the headers added to the response.</p>"},{"location":"features/response-errors/#custom-errors","title":"Custom Errors","text":"<p>It is possible to provide your own error model and have the built-in error utility functions use that model instead of the default one. This is useful if you want to provide more information in your error responses or your organization has requirements around the error response structure.</p> <p>This is accomplished by defining your custom model as a <code>huma.StatusError</code> and then overriding the built-in <code>huma.NewError</code> function:</p> code.go<pre><code>type MyError struct {\n\tstatus  int\n\tMessage string   `json:\"message\"`\n\tDetails []string `json:\"details,omitempty\"`\n}\n\nfunc (e *MyError) Error() string {\n\treturn e.Message\n}\n\nfunc (e *MyError) GetStatus() int {\n\treturn e.status\n}\n\nfunc main() {\n\thuma.NewError = func(status int, message string, errs ...error) huma.StatusError {\n\t\tdetails := make([]string, len(errs))\n\t\tfor i, err := range errs {\n\t\t\tdetails[i] = err.Error()\n\t\t}\n\t\treturn &amp;MyError{\n\t\t\tstatus:  status,\n\t\t\tMessage: message,\n\t\t\tDetails: details,\n\t\t}\n\t}\n\n\trouter := chi.NewMux()\n\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"get-error\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/error\",\n\t}, func(ctx context.Context, i *struct{}) (*struct{}, error) {\n\t\treturn nil, huma.Error404NotFound(\"not found\", fmt.Errorf(\"some-other-error\"))\n\t})\n\n\thttp.ListenAndServe(\":8888\", router)\n}\n</code></pre> <p>To change the default content type that is returned, you can also implement the <code>huma.ContentTypeFilter</code> interface.</p>"},{"location":"features/response-errors/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.ErrorModel</code> the default error model</li> <li><code>huma.ErrorDetail</code> describes location &amp; value of an error</li> <li><code>huma.StatusError</code> interface for custom errors</li> <li><code>huma.HeadersError</code> interface for errors with headers</li> <li><code>huma.ContentTypeFilter</code> interface for custom content types</li> </ul> </li> <li>External Links<ul> <li>HTTP Status Codes</li> <li>RFC 9457 Problem Details for HTTP APIs</li> </ul> </li> </ul>"},{"location":"features/response-outputs/","title":"Response Outputs","text":"<p>Responses can have an optional status code, headers, and/or body. Like inputs, they use standard Go structs which describe the entirety of the response.</p>"},{"location":"features/response-outputs/#status-code","title":"Status Code","text":"<p>Huma uses the following default response status codes:</p> <ul> <li><code>200</code> for responses with bodies</li> <li><code>204</code> for responses without a body</li> </ul> <p>You can override this behavior in two ways. The first is by setting <code>huma.Operation</code> <code>DefaultStatus</code> field at operation registration time.</p> code.go<pre><code>// Register an operation with a default status code of 201.\nhuma.Register(api, huma.Operation{\n\tOperationID:  \"create-thing\",\n\tMethod:       http.MethodPost,\n\tPath:         \"/things\",\n\tSummary:      \"Create a thing\",\n\tDefaultStatus: 201,\n}, func(ctx context.Context, input ThingRequest) (*struct{}, error) {\n\t// Do nothing...\n\treturn nil, nil\n})\n</code></pre> <p>If the response code needs to be dynamic, you can use the special <code>Status</code> field in your response struct. This is not recommended, but is available if needed.</p> code.go<pre><code>type ThingResponse struct {\n\tStatus int\n}\n\nhuma.Register(api, huma.Operation{\n\tOperationID:  \"get-thing\",\n\tMethod:       http.MethodGet,\n\tPath:         \"/things/{thing-id}\",\n\tSummary:      \"Get a thing by ID\",\n}, func(ctx context.Context, input *ThingRequest) (*ThingResponse, error) {\n\t// Create a response and set the dynamic status\n\tresp := &amp;ThingResponse{}\n\tif input.ID &lt; 500 {\n\t\tresp.Status = 200\n\t} else {\n\t\t// This is a made-up status code used for newer things.\n\t\tresp.Status = 250\n\t}\n\treturn resp, nil\n})\n</code></pre> <p>Dynamic Status</p> <p>It is much more common to set the default status code than to need a <code>Status</code> field in your response struct!</p>"},{"location":"features/response-outputs/#headers","title":"Headers","text":"<p>Headers are set by fields on the response struct. Here are the available tags:</p> Tag Description Example <code>header</code> Name of the response header <code>header:\"Authorization\"</code> <code>timeFormat</code> Format of a <code>time.Time</code> <code>timeFormat:\"Mon, 02 Jan 2006 15:04:05 GMT\"</code> <p>Here's an example of a response with several headers of different types:</p> code.go<pre><code>// Example struct with several headers\ntype MyOutput struct {\n\tContentType  string    `header:\"Content-Type\"`\n\tLastModified time.Time `header:\"Last-Modified\"`\n\tMyHeader     int       `header:\"My-Header\"`\n}\n</code></pre> <p>If the field type implements the <code>fmt.Stringer</code> interface then that will be used to convert the value to a string.</p>"},{"location":"features/response-outputs/#set-vs-append","title":"Set vs. Append","text":"<p>By default, headers are set on the response, which overwrites any existing header of the same name. If you want to append to an existing header, you can use an array of values instead of a single value.</p> code.go<pre><code>type MyOutput struct {\n\tMyHeader []string `header:\"My-Header\"`\n}\n</code></pre> <p>If you want to append just one header, you can use a slice with a single value.</p>"},{"location":"features/response-outputs/#cookies","title":"Cookies","text":"<p>You can set cookies in the response by using the <code>Set-Cookie</code> header. The <code>http.Cookie</code> type can be used to represent the cookie without needing to manually convert it to a string.</p> code.go<pre><code>type MyOutput struct {\n\tSetCookie http.Cookie `header:\"Set-Cookie\"`\n}\n\nhuma.Register(api, huma.Operation{\n\tOperationID: \"set-cookie\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/set-cookie\",\n\tSummary:     \"Set a cookie\",\n}, func(ctx context.Context, *struct{}) (*MyOutput, error) {\n\t// Create a response and set the cookie\n\tresp := &amp;MyOutput{\n\t\tSetCookie: http.Cookie{\n\t\t\tName:  \"session\",\n\t\t\tValue: \"123\",\n\t\t},\n\t}\n\treturn resp, nil\n})\n</code></pre> <p>You can set multiple cookies by using a slice like <code>[]http.Cookie</code> instead.</p>"},{"location":"features/response-outputs/#body","title":"Body","text":"<p>The special struct field <code>Body</code> will be treated as the response body and can refer to any other type or you can embed a struct or slice inline. A default <code>Content-Type</code> header will be set if none is present, selected via client-driven content negotiation with the server based on the registered serialization types.</p> <p>Example:</p> code.go<pre><code>type MyBody struct {\n\tName string `json:\"name\"`\n}\n\ntype MyOutput struct {\n\tBody MyBody\n}\n</code></pre> <p>The <code>nameHint</code> tag can be used on the <code>Body</code> field to hint at the schema name in the generated OpenAPI spec.</p> code.go<pre><code>type MyOutput struct {\n\tBody MyBody `nameHint:\"CustomResponseName\"`\n}\n</code></pre> <p>Use a type of <code>[]byte</code> to bypass serialization. This is useful for returning images, HTML, or other binary data.</p> code.go<pre><code>type MyOutput struct {\n\tBody []byte\n}\n</code></pre> <p>See the HTML Response or Image Response guides for more details.</p> <p>You can also stream the response body, see streaming for more details.</p>"},{"location":"features/response-outputs/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Register</code> registers new operations</li> <li><code>huma.Operation</code> the operation</li> </ul> </li> <li>External Links<ul> <li>HTTP Status Codes</li> </ul> </li> </ul>"},{"location":"features/response-serialization/","title":"Serialization","text":"<p>When handler functions return Go objects, they will be serialized to bytes for transmission back to the client.</p>"},{"location":"features/response-serialization/#default-formats","title":"Default Formats","text":"<p>The <code>config.Formats</code> maps either a content type name or extension (suffix) to a <code>huma.Format</code> instance.</p> <p>The default configuration for Huma includes support for JSON (RFC 8259) and optionally CBOR (RFC 7049) content types via the <code>Accept</code> header. This is done by registering the following content types using <code>huma.DefaultJSONFormat</code>:</p> <ul> <li><code>application/json</code></li> <li>Anything ending with <code>+json</code></li> </ul> <p>CBOR support can be enabled by importing the <code>cbor</code> package, which adds <code>cbor.DefaultCBORFormat</code> to the default list of formats:</p> main.go<pre><code>import (\n    \"github.com/danielgtaylor/huma/v2\"\n\n    _ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n</code></pre> <p>This adds the following content types:</p> <ul> <li><code>application/cbor</code></li> <li>Anything ending with <code>+cbor</code></li> </ul> <p>Other Formats</p> <p>You can easily add support for additional serialization formats, including binary formats like Protobuf if desired.</p>"},{"location":"features/response-serialization/#custom-formats","title":"Custom Formats","text":"<p>Huma supports custom serialization formats by implementing the <code>huma.Format</code> interface. Serialization formats are set on the API configuration at API creation time and selected by client-driven content negotiation.</p> <p>Writing a new format can be very simple, by just providing a marshal and unmarshal function:</p> code.go<pre><code>var DefaultJSONFormat = Format{\n\tMarshal: func(w io.Writer, v any) error {\n\t\treturn json.NewEncoder(w).Encode(v)\n\t},\n\tUnmarshal: json.Unmarshal,\n}\n</code></pre>"},{"location":"features/response-serialization/#content-negotiation","title":"Content Negotiation","text":"<p>Content negotiation allows clients to select the content type they are most comfortable working with when talking to the API. For request bodies, this uses the <code>Content-Type</code> header. For response bodies, it uses the <code>Accept</code> header. If none are present then JSON is usually selected as the default / preferred content type.</p> Terminal<pre><code># Send YAML as input using Restish\n$ echo 'foo: bar' | \\\n\trestish put api.rest.sh -H 'Content-Type:application/yaml'\n\n# Get CBOR output from an API\n$ restish api.rest.sh -H 'Accept:application/cbor'\nHTTP/2.0 200 OK\nContent-Length: 318\nContent-Type: application/cbor\nEtag: O7fTqWETqWI\n...\n</code></pre> <p>See the <code>negotiation</code> package for more info.</p>"},{"location":"features/response-serialization/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Config</code> the API config</li> <li><code>huma.DefaultConfig</code> the default API config</li> <li><code>huma.Format</code> to marshal/unmarshal data</li> </ul> </li> <li>External Links<ul> <li>RFC 8259 JSON</li> <li>RFC 7049 CBOR</li> </ul> </li> </ul>"},{"location":"features/response-streaming/","title":"Streaming","text":""},{"location":"features/response-streaming/#streaming_1","title":"Streaming","text":"<p>The response <code>Body</code> can be a callback function taking a <code>huma.Context</code> to facilitate streaming. The <code>huma.StreamResponse</code> utility makes this easy to return:</p> code.go<pre><code>func handler(ctx context.Context, input *MyInput) (*huma.StreamResponse, error) {\n\treturn &amp;huma.StreamResponse{\n\t\tBody: func(ctx huma.Context) {\n\t\t\t// Write header info before streaming the body.\n\t\t\tctx.SetHeader(\"Content-Type\", \"text/my-stream\")\n\t\t\twriter := ctx.BodyWriter()\n\n\t\t\t// Update the write deadline to give us extra time.\n\t\t\tif d, ok := writer.(interface{ SetWriteDeadline(time.Time) error }); ok {\n\t\t\t\td.SetWriteDeadline(time.Now().Add(5 * time.Second))\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"warning: unable to set write deadline\")\n\t\t\t}\n\n\t\t\t// Write the first message, then flush and wait.\n\t\t\twriter.Write([]byte(\"Hello, I'm streaming!\"))\n\t\t\tif f, ok := writer.(http.Flusher); ok {\n\t\t\t\tf.Flush()\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"error: unable to flush\")\n\t\t\t}\n\n\t\t\ttime.Sleep(3 * time.Second)\n\n\t\t\t// Write the second message.\n\t\t\twriter.Write([]byte(\"Hello, I'm still streaming!\"))\n\t\t},\n\t}, nil\n}\n</code></pre> <p>Also take a look at <code>http.ResponseController</code> which can be used to set timeouts, flush, etc in one simple interface.</p> <p>Server Sent Events</p> <p>The <code>sse</code> package provides a helper for streaming Server-Sent Events (SSE) responses that is easier to use than the above example!</p>"},{"location":"features/response-streaming/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Context</code> a router-agnostic request/response context</li> <li><code>huma.StreamResponse</code> for streaming output</li> </ul> </li> <li>External Links<ul> <li>Server Sent Events for one-way streaming</li> </ul> </li> </ul>"},{"location":"features/response-transformers/","title":"Response Transformers","text":""},{"location":"features/response-transformers/#response-transformers_1","title":"Response Transformers","text":"<p>Router middleware operates on router-specific request &amp; response objects whose bodies are <code>[]byte</code> slices or streams. Huma operations operate on specific struct instances. Sometimes there is a need to generically operate on structured response data after the operation handler has run but before the response is serialized to bytes. This is where response transformers come in.</p> <pre><code>flowchart LR\n\tRequest --&gt; Middleware\n\tMiddleware --&gt; Unmarshal\n\tsubgraph Huma\n\t\tUnmarshal --&gt; Handler\n\t\tHandler --&gt; Transformer\n\t\tTransformer --&gt; Marshal\n\tend\n\tMarshal --&gt; Response\n\n\tstyle Transformer stroke:#f9f,stroke-width:2px,stroke-dasharray: 5 5</code></pre> <p>Response transformers enable you to modify the response on the fly. For example, you could add a <code>Link</code> header to the response to indicate that the response body is described by a JSON Schema. This is done by implementing the <code>huma.Transformer</code> interface and registering it with the API.</p> <p>A simple for-fun example might look something like this:</p> code.go<pre><code>// FieldSelectTransform is an example of a transform that can use an input\n// header value to modify the response on the server, providing a GraphQL-like\n// way to send only the fields that the client wants over the wire.\nfunc FieldSelectTransform(ctx Context, status string, v any) (any, error) {\n\tif fields := ctx.Header(\"Fields\"); fields != \"\" {\n\t\t// Ugh this is inefficient... consider other ways of doing this :-(\n\t\tvar tmp any\n\t\tb, _ := json.Marshal(v)\n\t\tjson.Unmarshal(b, &amp;tmp)\n\t\tresult, _, err := shorthand.GetPath(fields, tmp, shorthand.GetOptions{})\n\t\treturn result, err\n\t}\n\treturn v, nil\n}\n</code></pre> <p>This could be used like so:</p> Terminal<pre><code>$ restish example.com/things/1 -H 'Fields: {id, tag_names: tags[].name}'\n</code></pre> <p>See the <code>huma.SchemaLinkTransformer</code> for a more real-world in-depth example.</p> <p>This transformer is what adds the <code>$schema</code> field and <code>Link</code> headers to responses. For information on how to disable it, see the JSON Schema documentation.</p>"},{"location":"features/response-transformers/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Transformer</code> response transformers</li> <li><code>huma.Config</code> the API config</li> </ul> </li> </ul>"},{"location":"features/schema-customization/","title":"Schema Customization","text":""},{"location":"features/schema-customization/#operation-schema","title":"Operation Schema","text":"<p>Schemas that are generated for input/output bodies can be customized in a couple of different ways. First, when registering your operation you can provide your own request and/or response schemas if you want to override the entire body. The automatic generation only applies when you have not provided your own schema in the OpenAPI.</p> code.go<pre><code>// Register an operation with a custom input body schema.\nhuma.Register(api, huma.Operation{\n\tOperationID: \"my-operation\",\n\tMethod:      http.MethodPut,\n\tPath:        \"/things/{thing-id}\",\n\tSummary:     \"Update a thing\",\n\tRequestBody: &amp;huma.RequestBody{\n\t\tDescription: \"My custom request schema\",\n\t\tContent: map[string]*huma.MediaType{\n\t\t\t\"application/json\": {\n\t\t\t\tSchema: &amp;huma.Schema{\n\t\t\t\t\tType: \t\t huma.TypeObject,\n\t\t\t\t\tProperties: map[string]*huma.Schema{\n\t\t\t\t\t\t\"foo\": {\n\t\t\t\t\t\t\tType: huma.TypeString,\n\t\t\t\t\t\t\tExtensions: map[string]any{\n\t\t\t\t\t\t\t\t\"x-custom-thing\": \"abc123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n}, func(ctx context.Context, input *MyInput) (*MyOutput, error) {\n\t// Implementation goes here...\n\treturn nil, nil\n})\n</code></pre>"},{"location":"features/schema-customization/#field-schema","title":"Field Schema","text":"<p>Second, this can be done on a per-field basis by making a struct that implements a special interface to get a schema, allowing you to e.g. encapsulate additional functionality within that field. This is the interface:</p> code.go<pre><code>// SchemaProvider is an interface that can be implemented by types to provide\n// a custom schema for themselves, overriding the built-in schema generation.\n// This can be used by custom types with their own special serialization rules.\ntype SchemaProvider interface {\n\tSchema(r huma.Registry) *huma.Schema\n}\n</code></pre> <p>The <code>huma.Registry</code> is passed to you and can be used to get schemas or refs for any embedded structs. Here is an example, where we want to know if a field was omitted vs. null vs. a value when sent as part of a request body. First we start by defining the custom generic struct:</p> code.go<pre><code>// OmittableNullable is a field which can be omitted from the input,\n// set to `null`, or set to a value. Each state is tracked and can\n// be checked for in handling code.\ntype OmittableNullable[T any] struct {\n\tSent  bool\n\tNull  bool\n\tValue T\n}\n\n// UnmarshalJSON unmarshals this value from JSON input.\nfunc (o *OmittableNullable[T]) UnmarshalJSON(b []byte) error {\n\tif len(b) &gt; 0 {\n\t\to.Sent = true\n\t\tif bytes.Equal(b, []byte(\"null\")) {\n\t\t\to.Null = true\n\t\t\treturn nil\n\t\t}\n\t\treturn json.Unmarshal(b, &amp;o.Value)\n\t}\n\treturn nil\n}\n\n// Schema returns a schema representing this value on the wire.\n// It returns the schema of the contained type.\nfunc (o OmittableNullable[T]) Schema(r huma.Registry) *huma.Schema {\n\treturn r.Schema(reflect.TypeOf(o.Value), true, \"\")\n}\n</code></pre> <p>This is how it can be used in an operation:</p> <pre><code>type MyResponse struct {\n\tBody struct {\n\t\tMessage string `json:\"message\"`\n\t}\n}\n\nhuma.Register(api, huma.Operation{\n\tOperationID: \"omittable\",\n\tMethod:      http.MethodPost,\n\tPath:        \"/omittable\",\n\tSummary:     \"Omittable / nullable example\",\n}, func(ctx context.Context, input *struct {\n\t// Making the body a pointer makes it optional, as it may be `nil`.\n\tBody *struct {\n\t\tName OmittableNullable[string] `json:\"name,omitempty\" maxLength:\"10\"`\n\t}\n}) (*MyResponse, error) {\n\tresp := &amp;MyResponse{}\n\tif input.Body == nil {\n\t\tresp.Body.Message = \"Body was not sent\"\n\t} else if !input.Body.Name.Sent {\n\t\tresp.Body.Message = \"Name was omitted from the request\"\n\t} else if input.Body.Name.Null {\n\t\tresp.Body.Message = \"Name was set to null\"\n\t} else {\n\t\tresp.Body.Message = \"Name was set to: \" + input.Body.Name.Value\n\t}\n\treturn resp, nil\n})\n</code></pre> <p>If you go to view the generated docs, you will see that the type of the <code>name</code> field is <code>string</code> and that it is optional, with a max length of 10, indicating that the custom schema was correctly used in place of one generated for the <code>OmittableNullable[string]</code> struct.</p> <p>See https://github.com/danielgtaylor/huma/blob/main/examples/omit/main.go for a full example along with how to call it. This just scratches the surface of what's possible with custom schemas for fields.</p>"},{"location":"features/schema-customization/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>huma.Schema</code> is a JSON Schema</li> <li><code>huma.Registry</code> generates &amp; stores JSON Schemas</li> <li><code>huma.DefaultSchemaNamer</code> names schemas from types</li> </ul> </li> <li>External Links<ul> <li>JSON Schema spec</li> <li>OpenAPI 3.1 spec</li> </ul> </li> <li>See Also<ul> <li>Config &amp; OpenAPI</li> </ul> </li> </ul>"},{"location":"features/server-sent-events-sse/","title":"Server Sent Events (SSE)","text":""},{"location":"features/server-sent-events-sse/#sse","title":"SSE","text":"<p>The <code>sse</code> package provides a helper for streaming Server-Sent Events (SSE) responses.</p> <p>SSE is a simple protocol for sending events from the server to the client over HTTP. It is a one-way protocol, meaning that the client cannot send events to the server, but can consume them as they are sent. It is popularly used as a push mechanism for web and other clients.</p>"},{"location":"features/server-sent-events-sse/#example","title":"Example","text":"<p>The <code>sse</code> package provides a simple API for sending events to the client and documents the event types and data structures in the OpenAPI spec if you provide a mapping of message type names to Go structs:</p> code.go<pre><code>// Register using sse.Register instead of huma.Register\nsse.Register(api, huma.Operation{\n\tOperationID: \"sse\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/sse\",\n\tSummary:     \"Server sent events example\",\n}, map[string]any{\n\t// Mapping of event type name to Go struct for that event.\n\t\"message\":      DefaultMessage{},\n\t\"userCreate\":   UserCreatedEvent{},\n\t\"mailReceived\": MailReceivedEvent{},\n}, func(ctx context.Context, input *struct{}, send sse.Sender) {\n\t// Send an event every second for 10 seconds.\n\tfor x := 0; x &lt; 10; x++ {\n\t\tsend.Data(MailReceivedEvent{UserID: \"abc123\"})\n\t\ttime.Sleep(1 * time.Second)\n\t}\n})\n</code></pre> <p>Type Reuse</p> <p>Each event model must be a unique Go type. If you want to reuse Go type definitions, you can define a new type referencing another type, e.g. <code>type MySpecificEvent MyBaseEvent</code> and it will work as expected.</p>"},{"location":"features/server-sent-events-sse/#sending-data","title":"Sending Data","text":"<p>The <code>send Sender</code> passed to your SSE operation handler provides several ways of sending data to the client:</p> Method Description <code>send(Message)</code> Send an event using a full message struct <code>send.Data(any)</code> Send a message with the given data <p>Unless you need to set the message ID or retry information, the <code>send.Data(any)</code> method is preferred.</p>"},{"location":"features/server-sent-events-sse/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Reference<ul> <li><code>sse.Register</code></li> <li><code>sse.Sender</code></li> </ul> </li> <li>External Links<ul> <li>Server Sent Events</li> </ul> </li> </ul>"},{"location":"features/test-utilities/","title":"Test Utilities","text":"<p>Huma includes a <code>humatest</code> package to make it easier to write tests for your API.</p>"},{"location":"features/test-utilities/#creating-a-test-api","title":"Creating a Test API","text":"<p>The first step is to create a test API instance. This is a router-agnostic API instance that you can register routes against and then make requests against.</p> code.go<pre><code>import (\n\t\"testing\"\n\n\t\"github.com/danielgtaylor/huma/v2/humatest\"\n)\n\nfunc TestMyAPI(t *testing.T) {\n\trouter, api := humatest.New(t)\n}\n</code></pre>"},{"location":"features/test-utilities/#registering-routes","title":"Registering Routes","text":"<p>The test API is the same as any other API, and you can register routes to it the same as you would your main API instance.</p> code.go<pre><code>func TestMyAPI(t *testing.T) {\n\trouter, api := humatest.New(t)\n\n\t// Register routes...\n\taddRoutes(api)\n}\n</code></pre>"},{"location":"features/test-utilities/#making-requests","title":"Making Requests","text":"<p>Once you have registered your routes, you can make requests against the test API instance. The <code>Get</code>, <code>Post</code>, <code>Put</code>, <code>Patch</code>, and <code>Delete</code> convenience methods are available on the test API object.</p> code.go<pre><code>func TestMyAPI(t *testing.T) {\n\trouter, api := humatest.New(t)\n\n\t// Register routes...\n\taddRoutes(api)\n\n\t// Make a GET request\n\tresp := api.Get(\"/some/path?foo=bar\")\n\n\t// Make a PUT request\n\tresp = api.Put(\"/some/path\",\n\t\t\"My-Header: abc123\",\n\t\tmap[string]any{\n\t\t\t\"author\": \"daniel\",\n\t\t\t\"rating\": 5,\n\t\t})\n}\n</code></pre> <p>The request convenience methods take a URL path followed by any number of optional arguments. If the argument is a string, it is treated as a header, if it is an <code>io.Reader</code> is is treated as the raw body, otherwise it is marshaled as JSON and used as the request body.</p>"},{"location":"features/test-utilities/#assertions","title":"Assertions","text":"<p>The request convenience methods return a <code>*httptest.ResponseRecorder</code> instance from the standard library. You can use the <code>Code</code> and <code>Body</code> fields to check the response status code and body.</p> code.go<pre><code>if resp.Code != http.StatusOK {\n\tt.Fail(\"Unexpected status code\", resp.Code)\n}\n\nif !strings.Contains(resp.Body.String(), \"some text\") {\n\tt.Fail(\"Unexpected response body\", resp.Body.String())\n}\n</code></pre> <p>Use whatever assertion library you want to make these checks. <code>stretchr/testify</code> is popular and easy to use.</p>"},{"location":"features/test-utilities/#dive-deeper","title":"Dive Deeper","text":"<ul> <li>Tutorial<ul> <li>Writing Tests</li> </ul> </li> <li>Reference<ul> <li><code>humatest</code></li> </ul> </li> <li>External Links<ul> <li>Go testing</li> </ul> </li> </ul>"},{"location":"how-to/conditional-fields/","title":"Conditional Fields","text":"<p>Some fields might be required only when other fields are present. This is know as <code>dependentRequired</code> in the JSON Schema.</p>"},{"location":"how-to/conditional-fields/#struct-tag","title":"Struct Tag","text":"<p>In Huma the <code>dependentRequired</code> tag is supported to apply conditional requirements to fields, as per the example below:</p> example.go<pre><code>type MyInput struct {\n    Value      string `json:\"value,omitempty\" dependentRequired:\"dependent1,dependent2\"`\n    Dependent1 string `json:\"dependent1,omitempty\"`\n    Dependent2 string `json:\"dependent2,omitempty\"`\n}\n</code></pre> <p>In the example above, all the fields are optional but, if <code>value</code> is sent, than both <code>dependent1</code> and <code>dependent2</code> must also be sent.</p>"},{"location":"how-to/conditional-fields/#schema","title":"Schema","text":"<p>It is also possible to change in the schema directly without using the struct tags. To do this, one must set the property <code>DependentRequired</code> in the desired schema to a <code>map[string][]string</code> where the key of the map is the field where the struct tag would be created, and the slice of strings is the dependent fields.</p>"},{"location":"how-to/custom-validation/","title":"Custom Validation","text":""},{"location":"how-to/custom-validation/#built-in-validators","title":"Built-in Validators","text":"<p>Huma ships with a lot of built-in validators based on JSON Schema. They support most basic use-cases and are preferred over writing your own code to do the same checks.</p> <p>Built-in validators include <code>minimum</code>, <code>maximum</code>, <code>multipleOf</code>, <code>minLength</code>, <code>maxLength</code>, <code>pattern</code>, <code>enum</code>, <code>minItems</code>, <code>maxItems</code>, etc. For example:</p> code.go<pre><code>type MyInput struct {\n\tThingID string `path:\"thing-id\" maxLength:\"12\"`\n\tTag     string `query:\"tag\" enum:\"foo,bar,baz\"`\n\tSales   uint   `query:\"sales\" maximum:\"1000\"`\n}\n</code></pre> <p>See Request Validation for all available validators. Some are added automatically, for example the <code>uint</code> above will automatically use <code>minimum:\"0\"</code> when generating the JSON Schema.</p>"},{"location":"how-to/custom-validation/#resolvers","title":"Resolvers","text":"<p>Sometimes you need to do more complex validation than what is possible with the built-in validators. For example, you might want to validate that a field value isn't some known bad value. In this case you can use a resolver. Resolvers are methods attached to inputs that are called during validation and can return errors.</p> code.go<pre><code>type MyInput struct {\n\tThingID string `path:\"thing-id\"`\n}\n\nfunc (i *MyInput) Resolve(ctx huma.Context) []error {\n\tif i.ThingID == \"bad\" {\n\t\treturn []error{&amp;huma.ErrorDetail{\n\t\t\tLocation: \"path.thing-id\",\n\t\t\tMessage:  \"Thing ID cannot be 'bad'\",\n\t\t\tValue:    i.ThingID,\n\t\t}}\n\t}\n\treturn nil\n}\n\nvar _ huma.Resolver = (*MyInput)(nil)\n</code></pre> <p>See Resolvers for more details.</p>"},{"location":"how-to/custom-validation/#example","title":"Example","text":"<p>Here's an example of using resolvers to provide additional validation for params and body fields, and how exhaustive errors are returned.</p> code.go<pre><code>// This example shows how to use resolvers to provide additional validation\n// for params and body fields, and how exhaustive errors are returned.\n//\n//\t# Example call returning seven errors\n//\trestish put :8888/count/3?count=15 -H Count:-3 count:9, nested.subCount: 6\n//\n//\t# Example success\n//\trestish put :8888/count/1 count:2, nested.subCount: 4\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `doc:\"Port to listen on.\" short:\"p\" default:\"8888\"`\n}\n\n// Create a new input type with additional validation attached to it.\ntype IntNot3 int\n\n// Resolve is called by Huma to validate the input. Prefix is the current\n// path like `path.to[3].field`, e.g. `query.count` or `body.nested.subCount`.\n// Resolvers can also be attached to structs to provide validation across\n// multiple field combinations, e.g. \"if foo is set then bar must be a\n// multiple of foo's value\". Use `prefix.With(\"bar\")` in that scenario.\nfunc (i IntNot3) Resolve(ctx huma.Context, prefix *huma.PathBuffer) []error {\n\tif i != 0 &amp;&amp; i%3 == 0 {\n\t\treturn []error{&amp;huma.ErrorDetail{\n\t\t\tLocation: prefix.String(),\n\t\t\tMessage:  \"Value cannot be a multiple of three\",\n\t\t\tValue:    i,\n\t\t}}\n\t}\n\treturn nil\n}\n\n// Ensure our resolver meets the expected interface.\nvar _ huma.ResolverWithPath = (*IntNot3)(nil)\n\nfunc main() {\n\t// Create the CLI, passing a function to be called with your custom options\n\t// after they have been parsed.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\trouter := chi.NewMux()\n\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register the greeting operation.\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"put-count\",\n\t\t\tSummary:     \"Put a count of things\",\n\t\t\tMethod:      http.MethodPut,\n\t\t\tPath:        \"/count/{count}\",\n\t\t}, func(ctx context.Context, input *struct {\n\t\t\tPathCount   IntNot3 `path:\"count\" example:\"2\" minimum:\"1\" maximum:\"10\"`\n\t\t\tQueryCount  IntNot3 `query:\"count\" example:\"2\" minimum:\"1\" maximum:\"10\"`\n\t\t\tHeaderCount IntNot3 `header:\"Count\" example:\"2\" minimum:\"1\" maximum:\"10\"`\n\t\t\tBody        struct {\n\t\t\t\tCount  IntNot3 `json:\"count\" example:\"2\" minimum:\"1\" maximum:\"10\"`\n\t\t\t\tNested *struct {\n\t\t\t\t\tSubCount IntNot3 `json:\"subCount\" example:\"2\" minimum:\"1\" maximum:\"10\"`\n\t\t\t\t} `json:\"nested,omitempty\"`\n\t\t\t}\n\t\t}) (*struct{}, error) {\n\t\t\tfmt.Printf(\"Got input: %+v\\n\", input)\n\t\t\treturn nil, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your router.\n\t\thooks.OnStart(func() {\n\t\t\t// Start the server\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n</code></pre>"},{"location":"how-to/graceful-shutdown/","title":"Graceful Shutdown","text":""},{"location":"how-to/graceful-shutdown/#stopping-the-server","title":"Stopping the Server","text":"<p>HTTP servers should not be shut down abruptly if it can be avoided. Instead, it's better to stop accepting new requests and give any in-flight requests a chance to finish before shutting down. This is called a \"graceful shutdown\".</p> <p>This can be accomplished in Huma using the CLI <code>hooks.OnStop()</code> hook, passing a function that shuts down the server with a timeout.</p>"},{"location":"how-to/graceful-shutdown/#example","title":"Example","text":"code.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingInput represents the greeting operation request.\ntype GreetingInput struct {\n\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router &amp; API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register GET /greeting/{name}\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-greeting\",\n\t\t\tSummary:     \"Get a greeting\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/greeting/{name}\",\n\t\t}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t\t\tresp := &amp;GreetingOutput{}\n\t\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Create the HTTP server.\n\t\tserver := http.Server{\n\t\t\tAddr:    fmt.Sprintf(\":%d\", options.Port),\n\t\t\tHandler: router,\n\t\t}\n\n\t\t// Tell the CLI how to start your router.\n\t\thooks.OnStart(func() {\n\t\t\tserver.ListenAndServe()\n\t\t})\n\n\t\t// Tell the CLI how to stop your server.\n\t\thooks.OnStop(func() {\n\t\t\t// Give the server 5 seconds to gracefully shut down, then give up.\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\t\tdefer cancel()\n\t\t\tserver.Shutdown(ctx)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n</code></pre> <p>Readiness Checks</p> <p>If using something like Kubernetes with readiness checks, and if the readiness route is registered on the same router as your Huma APIs, then the above code will cause the readiness check to start failing and Kubernetes will no longer route new requests to the shutting down pod as the existing connections drain.</p>"},{"location":"how-to/html-response/","title":"HTML Response","text":"<p>While Huma is primarily focused on providing REST APIs (JSON, CBOR, etc.), it is easy to return rendered HTML for some or all of your endpoints. This can be useful for server-side rendering (SSR), simple dashboards, or integrating with tools like HTMX.</p>"},{"location":"how-to/html-response/#basic-html-response","title":"Basic HTML Response","text":"<p>To return HTML, you can use a response struct with a <code>[]byte</code> body and set the <code>Content-Type</code> header to <code>text/html</code>.</p> main.go<pre><code>type MyHTMLOutput struct {\n\tContentType string `header:\"Content-Type\"`\n\tBody        []byte\n}\n\nhuma.Register(api, huma.Operation{\n\tOperationID: \"get-html\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/html\",\n}, func(ctx context.Context, input *struct{}) (*MyHTMLOutput, error) {\n\tresp := &amp;MyHTMLOutput{\n\t\tContentType: \"text/html\",\n\t\tBody:        []byte(\"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\"),\n\t}\n\treturn resp, nil\n})\n</code></pre>"},{"location":"how-to/html-response/#using-templ","title":"Using Templ","text":"<p>Templ is a popular type-safe HTML templating language for Go. You can use it with Huma by rendering the component to a buffer or using Huma's streaming support.</p>"},{"location":"how-to/html-response/#rendering-to-a-buffer","title":"Rendering to a Buffer","text":"main.go<pre><code>// hello.templ\n// package main\n// templ Hello(name string) {\n//   &lt;div&gt;Hello, { name }&lt;/div&gt;\n// }\n\nfunc GetHello(ctx context.Context, input *struct{ Name string `query:\"name\"` }) (*MyHTMLOutput, error) {\n\tcomponent := Hello(input.Name)\n\t\n\tbuf := new(bytes.Buffer)\n\tif err := component.Render(ctx, buf); err != nil {\n\t\treturn nil, huma.Error500InternalServerError(\"Error rendering template\", err)\n\t}\n\n\treturn &amp;MyHTMLOutput{\n\t\tContentType: \"text/html\",\n\t\tBody:        buf.Bytes(),\n\t}, nil\n}\n</code></pre>"},{"location":"how-to/html-response/#streaming-with-templ","title":"Streaming with Templ","text":"<p>For larger templates, you might want to stream the response directly to the client.</p> main.go<pre><code>huma.Register(api, huma.Operation{\n\tOperationID: \"get-html-stream\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/html-stream\",\n}, func(ctx context.Context, input *struct{}) (*huma.StreamResponse, error) {\n\treturn &amp;huma.StreamResponse{\n\t\tBody: func(hctx huma.Context) {\n\t\t\thctx.SetHeader(\"Content-Type\", \"text/html\")\n\t\t\tHello(\"World\").Render(ctx, hctx.BodyWriter())\n\t\t},\n\t}, nil\n})\n</code></pre>"},{"location":"how-to/html-response/#using-gomponents","title":"Using Gomponents","text":"<p>Gomponents allows you to build HTML components in pure Go.</p> main.go<pre><code>import \"github.com/maragudk/gomponents\"\nimport \"github.com/maragudk/gomponents/html\"\n\nfunc GetGomponents(ctx context.Context, input *struct{}) (*MyHTMLOutput, error) {\n\tnode := Doctype(\n\t\tHTML(\n\t\t\tHead(TitleEl(Text(\"Gomponents &amp; Huma\"))),\n\t\t\tBody(H1(Text(\"Hello from Gomponents\"))),\n\t\t),\n\t)\n\n\tbuf := new(bytes.Buffer)\n\tif err := node.Render(buf); err != nil {\n\t\treturn nil, huma.Error500InternalServerError(\"Error rendering components\", err)\n\t}\n\n\treturn &amp;MyHTMLOutput{\n\t\tContentType: \"text/html\",\n\t\tBody:        buf.Bytes(),\n\t}, nil\n}\n</code></pre>"},{"location":"how-to/html-response/#content-negotiation-for-html","title":"Content Negotiation for HTML","text":"<p>You can also use Huma's content negotiation to return either JSON or HTML depending on the client's <code>Accept</code> header. See Serialization and Transformers for more advanced use cases.</p>"},{"location":"how-to/html-response/#full-example","title":"Full Example","text":"<p>You can find a full runnable example of an HTML endpoint in the examples/html directory of the Huma repository.</p>"},{"location":"how-to/image-response/","title":"Image Response","text":""},{"location":"how-to/image-response/#image-response_1","title":"Image Response","text":"<p>Images or other encoded or binary responses can be returned by simply using a <code>[]byte</code> body and providing some additional information at operation registration time, such as the response body content type.</p>"},{"location":"how-to/image-response/#example","title":"Example","text":"code.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// ImageOutput represents the image operation response.\ntype ImageOutput struct {\n\tContentType string `header:\"Content-Type\"`\n\tBody        []byte\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router &amp; API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register GET /image\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-image\",\n\t\t\tSummary:     \"Get an image\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/image\",\n\t\t\tResponses: map[string]*huma.Response{\n\t\t\t\t\"200\": {\n\t\t\t\t\tDescription: \"Image response\",\n\t\t\t\t\tContent: map[string]*huma.MediaType{\n\t\t\t\t\t\t\"image/jpeg\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, func(ctx context.Context, input *struct{}) (*ImageOutput, error) {\n\t\t\tresp := &amp;ImageOutput{}\n\t\t\tresp.ContentType = \"image/png\"\n\t\t\tresp.Body = []byte{ /* ... image bytes here ... */ }\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n</code></pre>"},{"location":"how-to/migrate/","title":"Migrating From Huma V1","text":"<ol> <li>Import <code>github.com/danielgtaylor/huma/v2</code> instead of <code>github.com/danielgtaylor/huma</code>.</li> <li>Use the <code>humachi.NewV4</code> adapter as Huma v1 uses Chi v4 under the hood</li> <li>Attach your middleware to the <code>chi</code> instance.</li> <li>Replace resource &amp; operation creation with <code>huma.Register</code></li> <li>Rewrite handlers to be like <code>func(context.Context, *Input) (*Output, error)</code><ol> <li>Return errors instead of <code>ctx.WriteError(...)</code></li> <li>Return instances instead of <code>ctx.WriteModel(...)</code></li> </ol> </li> <li>Define options via a struct and use <code>humacli.New</code> to wrap the service</li> </ol> <p>Note that GraphQL support from Huma v1 has been removed. Take a look at alternative tools like https://www.npmjs.com/package/openapi-to-graphql which will automatically generate a GraphQL endpoint from Huma's generated OpenAPI spec.</p>"},{"location":"how-to/oauth2-jwt/","title":"OAuth 2.0 & JWT","text":""},{"location":"how-to/oauth2-jwt/#overview","title":"Overview","text":"<p>OAuth 2.0 is a popular open standard authorization framework that enables you to verify that incoming requests are authorized to use your API.</p> <p>There are three main pieces to using OAuth 2.0 with Huma:</p> <ol> <li>Issue an access token to a client application</li> <li>Document the auth scheme and required permissions</li> <li>Authorize incoming requests</li> </ol>"},{"location":"how-to/oauth2-jwt/#issue-an-access-token","title":"Issue an Access Token","text":"<p>Huma does not provide any built-in access token issuing functionality. Instead, you can use any existing library or service to issue tokens. For simplicity's sake, we will assume you are using a third-party service for managing users and issuing tokens, like Auth0 or Okta. A simplified flow chart for OAuth2.0 authorization looks something like this:</p> <pre><code>graph LR\n\tUser --&gt;|1: Login| Auth0\n\tAuth0 --&gt;|2: Issue access token| User\n\tAuth0 -.-&gt;|Refresh JWKS| API\n\tUser ---&gt;|3: Make request| API\n\tAPI --&gt;|4: Verify access token &amp; roles| Validate\n\tValidate --&gt;|5: Accept/reject| API\n\tAPI ---&gt;|6: Success| Handler</code></pre> <p>The access token may be issued in different flavors &amp; formats, but for the remainder of this document we will assume they are JWTs.</p> <p>You will configure the third-party service to issue access token from OAuth 2.0 flows like Authorization Code or Client Credentials (among others) and will be given e.g. authorization and token URLs, which will be used later in the OpenAPI and to configure clients to fetch access tokens.</p> <p>If not using a third-party service, you will need to set up a signing authority, publish your own JWKS, and issue short-lived tokens yourself. This is outside the scope of this guide, but take a look at github.com/lestrrat-go/jwx for a library that can help.</p>"},{"location":"how-to/oauth2-jwt/#document-the-auth-scheme-in-openapi","title":"Document the Auth Scheme in OpenAPI","text":"<p>Next, you need to document the auth scheme in your OpenAPI document. This is done using the <code>SecuritySchemes</code> component. Here is an example defining an OAuth 2.0 Authorization Code flow with the URLs mentioned above and a couple of defined scopes:</p> main.go<pre><code>router := chi.NewMux()\n\nconfig := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig.Components.SecuritySchemes = map[string]*huma.SecurityScheme{\n\t// Example Authorization Code flow.\n\t\"myAuth\": {\n\t\tType: \"oauth2\",\n\t\tFlows: &amp;huma.OAuthFlows{\n\t\t\tAuthorizationCode: &amp;huma.OAuthFlow{\n\t\t\t\tAuthorizationURL: \"https://example.com/oauth/authorize\",\n\t\t\t\tTokenURL:         \"https://example.com/oauth/token\",\n\t\t\t\tScopes: map[string]string{\n\t\t\t\t\t\"scope1\": \"Scope 1 description...\",\n\t\t\t\t\t\"scope2\": \"Scope 2 description...\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\n\t// Example alternative describing the use of JWTs without documenting how\n\t// they are issued or which flows might be supported. This is simpler but\n\t// tells clients less information.\n\t\"anotherAuth\": {\n\t\tType:         \"http\",\n\t\tScheme:       \"bearer\",\n\t\tBearerFormat: \"JWT\",\n\t},\n}\n\napi := humachi.New(router, config)\n</code></pre> <p>When registering your operation you can refer to the auth scheme and required scopes for that operation:</p> main.go<pre><code>huma.Register(api, huma.Operation{\n\tOperationID: \"get-greeting\",\n\tSummary:     \"Get a greeting\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/greeting/{name}\",\n\tSecurity: []map[string][]string{\n\t\t{\"myAuth\": {\"scope1\"}},\n\t},\n}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t// TODO: operation implementation goes here\n\treturn nil, nil\n})\n</code></pre> <p>Warning</p> <p>So far, the code above is only documenting the authorization scheme and required scopes, but does not actually authorize incoming requests. The next section will explain how to achieve the latter.</p>"},{"location":"how-to/oauth2-jwt/#authorize-incoming-requests","title":"Authorize Incoming Requests","text":"<p>Where authentication &amp; authorization happen depends on how your service is set up. In some scenarios you may have an API gateway that handles auth and forwards requests to your service. In other scenarios you may want to handle auth in your service.</p>"},{"location":"how-to/oauth2-jwt/#api-gateway-auth","title":"API Gateway Auth","text":"<p>In an API gateway scenario, you typically configure the gateway to check the <code>Authorization</code> header for a token and validate it against the JWKS URL. If the token is valid, then the gateway will forward the request to your API service. There are many such gateways (e.g. Traefik, Istio, etc) and ways of configuring them, but the general idea is similar between them:</p> <pre><code>graph LR\n\tAPIGateway[API Gateway]\n\tAuthMiddleware[Auth Middleware]\n\n\tUser --&gt;|Request| APIGateway\n\tAPIGateway --&gt; AuthMiddleware\n\tAuthMiddleware --&gt; APIGateway\n\tAPIGateway ---&gt;|Forward| API</code></pre> <p>In this case and depending on your security requirements, you may be able to skip this section since all incoming requests to your API will have already been vetted by the gateway. In this scenario, the Huma code from the previous section serves mostly as documentation for your clients.</p>"},{"location":"how-to/oauth2-jwt/#huma-auth-middleware","title":"Huma Auth Middleware","text":"<p>Huma provides middleware functionality that can be used to authorize incoming requests within the API service itself. Here is an example that will check the <code>Authorization</code> header for a token and validate it against the JWKS URL given by your JWT issuer (e.g. Auth0/Okta). It will also check that the token has the required scopes for the operation, if any are defined.</p> main.go<pre><code>import (\n\t\"github.com/lestrrat-go/jwx/v2/jwk\"\n\t\"github.com/lestrrat-go/jwx/v2/jwt\"\n)\n\n// NewJWKSet creates an auto-refreshing key set to validate JWT signatures.\nfunc NewJWKSet(jwkUrl string) jwk.Set {\n    jwkCache := jwk.NewCache(context.Background())\n\n    // register a minimum refresh interval for this URL.\n    // when not specified, defaults to Cache-Control and similar resp headers\n    err := jwkCache.Register(jwkUrl, jwk.WithMinRefreshInterval(10*time.Minute))\n    if err != nil {\n        panic(\"failed to register jwk location\")\n    }\n\n    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n    defer cancel()\n\n    // fetch once on application startup\n    _, err = jwkCache.Refresh(ctx, jwkUrl)\n    if err != nil {\n        panic(\"failed to fetch on startup\")\n    }\n    // create the cached key set\n    return jwk.NewCachedSet(jwkCache, jwkUrl)\n}\n\n// NewAuthMiddleware creates a middleware that will authorize requests based on\n// the required scopes for the operation.\nfunc NewAuthMiddleware(api huma.API, jwksURL string) func(ctx huma.Context, next func(huma.Context)) {\n\tkeySet := NewJWKSet(jwksURL)\n\n\treturn func(ctx huma.Context, next func(huma.Context)) {\n\t\tvar anyOfNeededScopes []string\n\t\tisAuthorizationRequired := false\n\t\tfor _, opScheme := range ctx.Operation().Security {\n\t\t\tvar ok bool\n\t\t\tif anyOfNeededScopes, ok = opScheme[\"myAuth\"]; ok {\n\t\t\t\tisAuthorizationRequired = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !isAuthorizationRequired {\n\t\t\tnext(ctx)\n\t\t\treturn\n\t\t}\n\n\t\ttoken := strings.TrimPrefix(ctx.Header(\"Authorization\"), \"Bearer \")\n\t\tif len(token) == 0 {\n\t\t\thuma.WriteErr(api, ctx, http.StatusUnauthorized, \"Unauthorized\")\n\t\t\treturn\n\t\t}\n\n\t\t// Parse and validate the JWT.\n\t\tparsed, err := jwt.ParseString(token,\n\t\t\tjwt.WithKeySet(keySet),\n\t\t\tjwt.WithValidate(true),\n\t\t\tjwt.WithIssuer(\"my-issuer\"),\n\t\t\tjwt.WithAudience(\"my-audience\"),\n\t\t)\n\t\tif err != nil {\n\t\t\thuma.WriteErr(api, ctx, http.StatusUnauthorized, \"Unauthorized\")\n\t\t\treturn\n\t\t}\n\n\t\t// Ensure the claims required for this operation are present.\n\t\tscopes, _ := parsed.Get(\"scopes\")\n\t\tif scopes, ok := scopes.([]string); ok {\n\t\t\tfor _, scope := range scopes {\n\t\t\t\tif slices.Contains(anyOfNeededScopes, scope) {\n\t\t\t\t\tnext(ctx)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thuma.WriteErr(api, ctx, http.StatusForbidden, \"Forbidden\")\n\t}\n}\n</code></pre> <p>Lastly, when configuring your API, be sure to include this middleware:</p> main.go<pre><code>api.UseMiddleware(NewAuthMiddleware(api, \"https://example.com/.well-known/jwks.json\"))\n</code></pre>"},{"location":"how-to/oauth2-jwt/#supporting-different-token-formats","title":"Supporting different Token Formats","text":"<p>As mentioned previously, the Oauth2.0 standard does not specify the format of the access token - it merely defines how to get one. Although JWT is a very popular format, a given OAuth2.0 service or library may issue access token in different formats. The gist of what is outlined above should be adaptable to support such tokens as well, but will obviously require different methods for validation and information extraction. In the case of opaque tokens, additional interaction with an IAM server may be required inside the middleware, e.g. calling an introspection endpoint.</p>"},{"location":"how-to/oauth2-jwt/#optional-client-auto-configuration","title":"Optional: Client Auto-Configuration","text":"<p>Some clients like Restish support OpenAPI-based auth auto-configuration. This means that you can configure your client to fetch the OpenAPI document and automatically configure itself to use the correct auth mechanism. This is done by adding the <code>x-cli-config</code> extension to the OpenAPI:</p> main.go<pre><code>config.Extensions[\"x-cli-config\"] = huma.AutoConfig{ /* ... */ }\n</code></pre>"},{"location":"tutorial/cli-client/","title":"CLI Client","text":"<p>It's useful to have a terminal or command-line client for your API, so you can test it out and see how it works.</p> <p>While Huma doesn't include this functionality built-in, you can utilize Restish to quickly get a CLI up and running. Restish provides a nicer high-level interface to your API than just using <code>curl</code> or <code>httpie</code> directly, by providing commands for each operation, converting inputs into command-line arguments and options, and generating useful help documentation.</p>"},{"location":"tutorial/cli-client/#install-restish","title":"Install Restish","text":"<p>First, install Restish:</p> MacLinuxWindows <p>Install using Homebrew, Go, or download a release.</p> Terminal<pre><code># Homebrew\n$ brew tap danielgtaylor/restish\n$ brew install restish\n\n# Go (requires Go 1.18+)\n$ go install github.com/danielgtaylor/restish@latest\n</code></pre> <p>Install using Go, Homebrew for Linux, or download a release.</p> Terminal<pre><code># Go (requires Go 1.18+)\n$ go install github.com/danielgtaylor/restish@latest\n\n# Homebrew for Linux\n$ brew tap danielgtaylor/restish\n$ brew install restish\n</code></pre> <p>Install using Go or download a release.</p> Terminal<pre><code># Go (requires Go 1.18+)\n$ go install github.com/danielgtaylor/restish@latest\n</code></pre> <p>Also consider setting up shell command-line completion for Restish.</p>"},{"location":"tutorial/cli-client/#configure-your-api","title":"Configure your API","text":"<p>Next, we need to tell Restish about your API and give it a short name, which we'll call <code>tutorial</code>. Do this using the <code>api configure</code> command. This only needs to be done one time. Make sure your API is running and accessible before continuing, as this pulls the OpenAPI spec from the service.</p>"},{"location":"tutorial/cli-client/#calling-the-api","title":"Calling the API","text":"<p>Once configured, you can call the API operations using high-level commands generated from the OpenAPI operation IDs:</p> <p>See the help commands like <code>restish tutorial --help</code> or <code>restish tutorial get-greeting --help</code> for more details. If you set up command-line completion, you can also use tab to see all available commands.</p>"},{"location":"tutorial/cli-client/#review","title":"Review","text":"<p>Congratulations! You just learned:</p> <ul> <li>How to install Restish</li> <li>How to configure Restish for your API</li> <li>How to call your API using Restish</li> <li>How to pass parameters and body content to Restish</li> </ul>"},{"location":"tutorial/cli-client/#dive-deeper","title":"Dive Deeper","text":"<p>Want to learn more about how Restish works and how to use it? Check these out next:</p> <ul> <li>Restish</li> <li>Restish OpenAPI 3 support</li> <li>Restish input</li> <li>A CLI for REST APIs</li> </ul>"},{"location":"tutorial/client-sdks/","title":"Client SDKs","text":"<p>Several tools can be used to create SDKs from an OpenAPI spec. Let's use the <code>oapi-codegen</code> Go code generator to create a Go SDK, and then build a client using that SDK.</p>"},{"location":"tutorial/client-sdks/#add-an-openapi-command","title":"Add an OpenAPI Command","text":"<p>First, let's create a command to grab the OpenAPI spec so the service doesn't need to be running and you can generate the SDK as needed (e.g. as part of the API service release process).</p> main.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\n// ReviewInput represents the review operation request.\ntype ReviewInput struct {\n\tBody struct {\n\t\tAuthor  string `json:\"author\" maxLength:\"10\" doc:\"Author of the review\"`\n\t\tRating  int    `json:\"rating\" minimum:\"1\" maximum:\"5\" doc:\"Rating from 1 to 5\"`\n\t\tMessage string `json:\"message,omitempty\" maxLength:\"100\" doc:\"Review message\"`\n\t}\n}\n\nfunc addRoutes(api huma.API) {\n\t// Register GET /greeting/{name}\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"get-greeting\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/greeting/{name}\",\n\t\tSummary:     \"Get a greeting\",\n\t\tDescription: \"Get a greeting for a person by name.\",\n\t\tTags:        []string{\"Greetings\"},\n\t}, func(ctx context.Context, input *struct{\n\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t}) (*GreetingOutput, error) {\n\t\tresp := &amp;GreetingOutput{}\n\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\treturn resp, nil\n\t})\n\n\t// Register POST /reviews\n\thuma.Register(api, huma.Operation{\n\t\tOperationID:   \"post-review\",\n\t\tMethod:        http.MethodPost,\n\t\tPath:          \"/reviews\",\n\t\tSummary:       \"Post a review\",\n\t\tTags:          []string{\"Reviews\"},\n\t\tDefaultStatus: http.StatusCreated,\n\t}, func(ctx context.Context, i *ReviewInput) (*struct{}, error) {\n\t\t// TODO: save review in data store.\n\t\treturn nil, nil\n\t})\n}\n\nfunc main() {\n\tvar api huma.API\n\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router &amp; API\n\t\trouter := chi.NewMux()\n\t\tapi = humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\taddRoutes(api)\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Add a command to print the OpenAPI spec.\n\tcli.Root().AddCommand(&amp;cobra.Command{\n\t\tUse:   \"openapi\",\n\t\tShort: \"Print the OpenAPI spec\",\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\t// Use downgrade to return OpenAPI 3.0.3 YAML since oapi-codegen doesn't\n\t\t\t// support OpenAPI 3.1 fully yet. Use `.YAML()` instead for 3.1.\n\t\t\tb, _ := api.OpenAPI().DowngradeYAML()\n\t\t\tfmt.Println(string(b))\n\t\t},\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n</code></pre>"},{"location":"tutorial/client-sdks/#generate-the-sdk","title":"Generate the SDK","text":"<p>First, grab the OpenAPI spec. Then install and use the generator to create the SDK.</p>"},{"location":"tutorial/client-sdks/#build-the-client","title":"Build the Client","text":"<p>Next, we can use the SDK by writing a small client script.</p> client/client.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/my-user/my-api/sdk\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Initialize an SDK client.\n\tclient, _ := sdk.NewClientWithResponses(\"http://localhost:8888\")\n\n\t// Make the greeting request.\n\tgreeting, err := client.GetGreetingWithResponse(ctx, \"world\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif greeting.StatusCode() &gt; 200 {\n\t\tpanic(greeting.ApplicationproblemJSONDefault)\n\t}\n\n\t// Everything was successful, so print the message.\n\tfmt.Println(greeting.JSON200.Message)\n}\n</code></pre>"},{"location":"tutorial/client-sdks/#run-the-client","title":"Run the Client","text":"<p>Now you're ready to run the client:</p>"},{"location":"tutorial/client-sdks/#review","title":"Review","text":"<p>Congratulations! You just learned:</p> <ul> <li>How to install an SDK generator</li> <li>How to generate a Go SDK for your API</li> <li>How to build a client using the SDK to call the API</li> </ul>"},{"location":"tutorial/client-sdks/#external-resources","title":"External Resources","text":"<p>For a more in-depth real-world example, check out How to build an API with Go and Huma on the Zuplo blog. It covers:</p> <ul> <li>Creating a new Huma project &amp; defining some endpoints</li> <li>Setting up MongoDB</li> <li>Running the service</li> <li>Hosting our API</li> <li>Creating a project on Zuplo</li> <li>Setting up API key authentication</li> </ul>"},{"location":"tutorial/client-sdks/#dive-deeper","title":"Dive Deeper","text":"<p>Want to learn more about OpenAPI tooling like SDK generators and how to use them? Check these out next:</p> <ul> <li>SDK Generators<ul> <li><code>oapi-codegen</code></li> <li>OpenAPI Generator</li> </ul> </li> <li>OpenAPI Tool Directories<ul> <li>openapi.tools</li> <li>tools.openapis.org</li> </ul> </li> </ul>"},{"location":"tutorial/installation/","title":"Installation","text":""},{"location":"tutorial/installation/#prerequisites","title":"Prerequisites","text":"<p>Huma requires Go 1.25 or newer, so install that first. You'll also want some kind of text editor or IDE to write code and a terminal to run commands.</p>"},{"location":"tutorial/installation/#project-setup","title":"Project Setup","text":"<p>Next, open a terminal and create a new Go project, then go get the Huma dependency to it's ready to be imported:</p> <p>You should now have a directory structure like this:</p> Directory Structure<pre><code>my-api/\n  |-- go.mod\n  |-- go.sum\n</code></pre> <p>That's it! Now you are ready to build your first Huma API!</p>"},{"location":"tutorial/sending-data/","title":"Sending Data","text":"<p>Let's level up our API and accept some data from the user.</p> API Design<pre><code>Request:\nPOST /reviews\n{\n\t\"author\": \"Daniel\",\n\t\"rating\": 5,\n\t\"message\": \"Some custom review message\"\n}\n\nResponse: 201 Created\n</code></pre>"},{"location":"tutorial/sending-data/#put-review","title":"Put Review","text":"<p>Add a new operation to our API that allows users to submit reviews of our product.</p> main.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\n// ReviewInput represents the review operation request.\ntype ReviewInput struct {\n\tBody struct {\n\t\tAuthor  string `json:\"author\" maxLength:\"10\" doc:\"Author of the review\"`\n\t\tRating  int    `json:\"rating\" minimum:\"1\" maximum:\"5\" doc:\"Rating from 1 to 5\"`\n\t\tMessage string `json:\"message,omitempty\" maxLength:\"100\" doc:\"Review message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router &amp; API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register GET /greeting/{name}\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-greeting\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/greeting/{name}\",\n\t\t\tSummary:     \"Get a greeting\",\n\t\t\tDescription: \"Get a greeting for a person by name.\",\n\t\t\tTags:        []string{\"Greetings\"},\n\t\t}, func(ctx context.Context, input *struct{\n\t\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t\t}) (*GreetingOutput, error) {\n\t\t\tresp := &amp;GreetingOutput{}\n\t\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Register POST /reviews\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID:   \"post-review\",\n\t\t\tMethod:        http.MethodPost,\n\t\t\tPath:          \"/reviews\",\n\t\t\tSummary:       \"Post a review\",\n\t\t\tTags:          []string{\"Reviews\"},\n\t\t\tDefaultStatus: http.StatusCreated,\n\t\t}, func(ctx context.Context, i *ReviewInput) (*struct{}, error) {\n\t\t\t// TODO: save review in data store.\n\t\t\treturn nil, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n</code></pre>"},{"location":"tutorial/sending-data/#calling-the-api","title":"Calling the API","text":"<p>Make a request to the API:</p> <p>You can also try sending invalid data, and see how you get exhaustive errors back from your API. Omit the <code>author</code> body field and use a rating outside the range of valid values:</p>"},{"location":"tutorial/sending-data/#review","title":"Review","text":"<p>Congratulations! You just learned:</p> <ul> <li>How to add a new operation to your API</li> <li>How to set a default status code for an operation</li> <li>How to accept data from the user</li> <li>How built-in validation returns errors to the user</li> <li>How to use the <code>omitempty</code> struct tag to make fields optional</li> </ul>"},{"location":"tutorial/sending-data/#dive-deeper","title":"Dive Deeper","text":"<p>Want to learn more about how sending data works? Check these out next:</p> <ul> <li>Request Inputs</li> <li>Validation</li> <li>Resolvers</li> <li>Limits</li> </ul>"},{"location":"tutorial/service-configuration/","title":"Service Configuration","text":"<p>Huma includes a basic command-line and environment variable option parser that can be used to provide runtime configuration to your service. This lets you pass in things like the port the service runs on, which environment to tag logs with, secrets and endpoints for dependencies like databases, etc.</p>"},{"location":"tutorial/service-configuration/#port-option","title":"Port Option","text":"<p>Your first API can be updated to take an optional network port parameter like this:</p> main.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router &amp; API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register GET /greeting/{name}\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-greeting\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/greeting/{name}\",\n\t\t\tSummary:     \"Get a greeting\",\n\t\t\tDescription: \"Get a greeting for a person by name.\",\n\t\t\tTags:        []string{\"Greetings\"},\n\t\t}, func(ctx context.Context, input *struct{\n\t\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t\t}) (*GreetingOutput, error) {\n\t\t\tresp := &amp;GreetingOutput{}\n\t\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n</code></pre> <p>Just like requests and responses, the CLI options are defined using a custom struct with a field for each option. Once defined, all that's left is to wrap your service startup code and then run the CLI from your <code>main</code> function.</p>"},{"location":"tutorial/service-configuration/#passing-options","title":"Passing Options","text":"<p>Options can be passed explicitly as command-line arguments to the service or they can be provided by environment variables prefixed with <code>SERVICE_</code>. For example, to run the service on port 8000:</p> <pre><code># Example passing command-line args\n$ go run main.go --port=8000\n\n# Short arguments are also supported\n$ go run main.go -p 8000\n\n# Example passing by environment variables\n$ SERVICE_PORT=8000 go run main.go\n</code></pre> <p>Precedence</p> <p>If both environment variable and command-line arguments are present, then command-line arguments take priority.</p>"},{"location":"tutorial/service-configuration/#review","title":"Review","text":"<p>Congratulations! You just learned:</p> <ul> <li>How to add a CLI option to your service</li> <li>How to pass options via command-line arguments or environment variables</li> </ul>"},{"location":"tutorial/service-configuration/#dive-deeper","title":"Dive Deeper","text":"<p>Want to learn more about how the CLI works and how to use it? Check these out next:</p> <ul> <li>CLI intro</li> <li>CLI option types &amp; tags</li> <li>CLI custom commands</li> </ul>"},{"location":"tutorial/writing-tests/","title":"Writing Tests","text":"<p>Huma provides a number of helpers for testing your API. The most important is the <code>humatest</code> package, which allows you to run a test server and make requests against it.</p>"},{"location":"tutorial/writing-tests/#testable-code","title":"Testable Code","text":"<p>First, modify the service code to make it easier to test, by moving the operation registration code out of the <code>main</code> function:</p> main.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\n// ReviewInput represents the review operation request.\ntype ReviewInput struct {\n\tBody struct {\n\t\tAuthor  string `json:\"author\" maxLength:\"10\" doc:\"Author of the review\"`\n\t\tRating  int    `json:\"rating\" minimum:\"1\" maximum:\"5\" doc:\"Rating from 1 to 5\"`\n\t\tMessage string `json:\"message,omitempty\" maxLength:\"100\" doc:\"Review message\"`\n\t}\n}\n\nfunc addRoutes(api huma.API) {\n\t// Register GET /greeting/{name}\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"get-greeting\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/greeting/{name}\",\n\t\tSummary:     \"Get a greeting\",\n\t\tDescription: \"Get a greeting for a person by name.\",\n\t\tTags:        []string{\"Greetings\"},\n\t}, func(ctx context.Context, input *struct{\n\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t}) (*GreetingOutput, error) {\n\t\tresp := &amp;GreetingOutput{}\n\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\treturn resp, nil\n\t})\n\n\t// Register POST /reviews\n\thuma.Register(api, huma.Operation{\n\t\tOperationID:   \"post-review\",\n\t\tMethod:        http.MethodPost,\n\t\tPath:          \"/reviews\",\n\t\tSummary:       \"Post a review\",\n\t\tTags:          []string{\"Reviews\"},\n\t\tDefaultStatus: http.StatusCreated,\n\t}, func(ctx context.Context, i *ReviewInput) (*struct{}, error) {\n\t\t// TODO: save review in data store.\n\t\treturn nil, nil\n\t})\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router &amp; API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\taddRoutes(api)\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n</code></pre>"},{"location":"tutorial/writing-tests/#writing-tests_1","title":"Writing Tests","text":"<p>Use the <code>humatest</code> package to create a test API and then register your routes against it. Next, make get or post requests against it to test the various user scenarios you have to support:</p> main_test.go<pre><code>package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/danielgtaylor/huma/v2/humatest\"\n)\n\nfunc TestGetGreeting(t *testing.T) {\n\t_, api := humatest.New(t)\n\n\taddRoutes(api)\n\n\tresp := api.Get(\"/greeting/world\")\n\tif !strings.Contains(resp.Body.String(), \"Hello, world!\") {\n\t\tt.Fatalf(\"Unexpected response: %s\", resp.Body.String())\n\t}\n}\n\nfunc TestPutReview(t *testing.T) {\n\t_, api := humatest.New(t)\n\n\taddRoutes(api)\n\n\tresp := api.Post(\"/reviews\", map[string]any{\n\t\t\"author\": \"daniel\",\n\t\t\"rating\": 5,\n\t})\n\n\tif resp.Code != 201 {\n\t\tt.Fatalf(\"Unexpected status code: %d\", resp.Code)\n\t}\n}\n\nfunc TestPutReviewError(t *testing.T) {\n\t_, api := humatest.New(t)\n\n\taddRoutes(api)\n\n\tresp := api.Post(\"/reviews\", map[string]any{\n\t\t\"rating\": 10,\n\t})\n\n\tif resp.Code != 422 {\n\t\tt.Fatalf(\"Unexpected status code: %d\", resp.Code)\n\t}\n}\n</code></pre> <p>Now you can run your tests!</p> Terminal<pre><code>$ go test -cover\n</code></pre> <p>You may also need to send requests with a custom <code>context.Context</code>. For example, you may need to test an authenticated route, or test using some other request-specific values.</p> <pre><code>func TestGetGreeting(t *testing.T) {\n\t_, api := humatest.New(t)\n\n\taddRoutes(api)\n\t\n\tctx := context.Background() // define your necessary context\n\n\tresp := api.GetCtx(ctx, \"/greeting/world\") // provide it using the 'Ctx' suffixed methods\n\tif !strings.Contains(resp.Body.String(), \"Hello, world!\") {\n\t\tt.Fatalf(\"Unexpected response: %s\", resp.Body.String())\n\t}\n}\n</code></pre>"},{"location":"tutorial/writing-tests/#review","title":"Review","text":"<p>Congratulations! You just learned:</p> <ul> <li>How to write tests for your API</li> <li>How to use the <code>humatest</code> package to create a test API</li> <li>How to use the <code>humatest</code> package to make requests against your API</li> <li>How to run tests and get code coverage</li> </ul>"},{"location":"tutorial/writing-tests/#dive-deeper","title":"Dive Deeper","text":"<p>Want to learn more about how testing works? Check these out next:</p> <ul> <li>Operations</li> <li>Test Utilities</li> <li><code>humatest</code> reference</li> </ul>"},{"location":"tutorial/your-first-api/","title":"Your First API","text":"<p>Let's build a simple API that greets people. We will take the person's name as a URL path parameter and respond with a JSON body containing a greeting message to that person. Here's the high-level API design:</p> API Design<pre><code>Request:\nGET /greeting/{name}\n\nResponse:\n{\n\t\"message\": \"Hello, {name}!\"\n}\n</code></pre>"},{"location":"tutorial/your-first-api/#response-output","title":"Response Output","text":"<p>Start by making a new file <code>main.go</code> and adding the greet operation's response output model, which has a body with a <code>message</code> field for the greeting message:</p> main.go<pre><code>package main\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n</code></pre> <p>Requests and responses may define a field <code>Body</code> which will be used to marshal or unmarshal the request or response body.</p> <p>The <code>example</code> and <code>doc</code> tags are used to generate friendly API documentation via OpenAPI.</p> <p>You should now have a directory structure that looks like:</p> Directory Structure<pre><code>my-api/\n  |-- go.mod\n  |-- go.sum\n\t|-- main.go\n</code></pre>"},{"location":"tutorial/your-first-api/#router-api","title":"Router &amp; API","text":"<p>Let's create a router, which will handle getting incoming requests to the correct operation handler, and a new API instance where we can register our operation.</p> main.go<pre><code>package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a new router &amp; API\n\trouter := chi.NewMux()\n\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t// TODO: Register operations...\n\n\t// Start the server!\n\thttp.ListenAndServe(\"127.0.0.1:8888\", router)\n}\n</code></pre> <p>Router</p> <p>We are using the Chi for this example, but if you want to use the built-in Go 1.22+ router, you can do this instead:</p> main.go<pre><code>router := http.NewServeMux()\napi := humago.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n</code></pre> <p>Lots of other routers are supported too.</p>"},{"location":"tutorial/your-first-api/#operation","title":"Operation","text":"<p>Register the operation with the Huma API instance, including how it maps to a URL. The handler function will take in a struct that defines its inputs (in this case a path parameter named <code>name</code>) and return the <code>GreetingOutput</code> model we built above.</p> main.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a new router &amp; API.\n\trouter := chi.NewMux()\n\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t// Register GET /greeting/{name} handler.\n\thuma.Get(api, \"/greeting/{name}\", func(ctx context.Context, input *struct{\n\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t}) (*GreetingOutput, error) {\n\t\tresp := &amp;GreetingOutput{}\n\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\treturn resp, nil\n\t})\n\n\t// Start the server!\n\thttp.ListenAndServe(\"127.0.0.1:8888\", router)\n}\n</code></pre> <p>The <code>path</code> tag tells Huma that this field should be read from the URL path. The <code>maxLength</code> tag tells Huma that the name should be no longer than 30 characters.</p> <p>Download dependencies for <code>main.go</code>:</p> <pre><code>$ go mod tidy\n</code></pre> <p>Congratulations! This is a fully functional Huma API!</p>"},{"location":"tutorial/your-first-api/#calling-the-api","title":"Calling the API","text":"<p>Let's test it out! Start the server:</p> <pre><code>$ go run .\n</code></pre> <p>In another terminal window, make a request to the API using Restish or curl:</p> RestishCurl <p></p> Terminal<pre><code># Get a greeting from the API\n$ curl http://localhost:8888/greeting/world\n</code></pre> <p>Schemas</p> <p>You can ignore the <code>Link</code> header and <code>$schema</code> field for now. These are added automatically by Huma to help clients discover information about the API, and to provide things like auto-completion and linting in editors.</p>"},{"location":"tutorial/your-first-api/#api-documentation","title":"API Documentation","text":"<p>Go to http://localhost:8888/docs to see the interactive generated documentation for the API. It should look something like this:</p> <p></p> <p>Using the panel at the top right of the documentation page you can send a request to the API and see the response.</p> <p>These docs are generated from the OpenAPI specification. You can use this file to generate documentation, client libraries, commandline clients, mock servers, and more. Two versions are provided by Huma. It is recommended to use OpenAPI 3.1, but OpenAPI 3.0.3 is also available for compatibility with older tools:</p> <ul> <li>OpenAPI 3.1 JSON: http://localhost:8888/openapi.json</li> <li>OpenAPI 3.1 YAML: http://localhost:8888/openapi.yaml</li> <li>OpenAPI 3.0.3 JSON: http://localhost:8888/openapi-3.0.json</li> <li>OpenAPI 3.0.3 YAML: http://localhost:8888/openapi-3.0.yaml</li> </ul>"},{"location":"tutorial/your-first-api/#enhancing-documentation","title":"Enhancing Documentation","text":"<p>You can use <code>huma.Register</code> to add more information to the OpenAPI specification, such as descriptions with Markdown, examples, tags, and more. The <code>huma.Operation</code> struct provides full access to the OpenAPI including the ability to add extensions. See the <code>huma.Operation</code> struct for more details.</p> main.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a new router &amp; API\n\trouter := chi.NewMux()\n\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t// Register GET /greeting/{name}\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"get-greeting\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/greeting/{name}\",\n\t\tSummary:     \"Get a greeting\",\n\t\tDescription: \"Get a greeting for a person by name.\",\n\t\tTags:        []string{\"Greetings\"},\n\t}, func(ctx context.Context, input *struct{\n\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t}) (*GreetingOutput, error) {\n\t\tresp := &amp;GreetingOutput{}\n\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\treturn resp, nil\n\t})\n\n\t// Start the server!\n\thttp.ListenAndServe(\"127.0.0.1:8888\", router)\n}\n</code></pre> <p>Now restart the server and take a look at your updated docs!</p>"},{"location":"tutorial/your-first-api/#review","title":"Review","text":"<p>Congratulations! You just learned:</p> <ul> <li>Creating Huma input and output models</li> <li>Creating a Golang REST API with Huma</li> <li>How to make requests to the API</li> <li>How to view the generated documentation</li> </ul> <p>Read on to learn how to level up your API with even more features.</p>"},{"location":"why/","title":"Why Huma?","text":""},{"location":"why/#production-ready","title":"Production Ready","text":"<p>Huma is a proven production-ready technology that has been used by large successful companies and products with millions of customers in the live streaming video space for years.</p> <p>Huma is fast to learn, easy to use, performant, and lets your organization ship APIs and related tooling like interactive documentation, CLIs and SDKs faster and with fewer bugs caused by human-error and manual processes.</p> <p>Daniel (Engineer @ Warner Bros Discovery)</p> <p>Huma has been vital for quickly building consistent, standards-compliant, well-documented APIs and generated clients &amp; SDKs for our live media streaming control plane services for configuring and running live news and sporting event channels. Teams have been able to ship faster and with fewer bugs since switching to Huma.</p>"},{"location":"why/#compatibility","title":"Compatibility","text":"<p>Huma is broadly compatible with the libraries and tools your organization is already using. It is a micro-framework meant to level up your team's API development experience without getting in your way.</p>"},{"location":"why/#huma-standards","title":"Huma \u2764\ufe0f Standards","text":"<p>Huma is built on top of open industry standards like OpenAPI, JSON Schema, and dozens of RFCs and industry best practices.</p> <p>This results in broad compatibility with other tools &amp; systems, as well as the ability to generate and automate many pieces of your workflow, including client SDK generation, documentation, and more.</p> <p>Well-known and understood standards means developers can get up to speed faster and spend less time learning new concepts. A new team can adopt Go and Huma and be productive in a matter of days.</p> <p> Config &amp; OpenAPI  JSON Schema &amp; Registry  Serialization  PATCH formats</p>"},{"location":"why/#go-is-awesome","title":"Go is Awesome","text":"<p>Huma is built on Go, which is an easy to learn, performant, and extremely powerful Top 10 programming language.</p> <p>Huma is built on top of idiomatic Go conventions and utilizes standard library concepts like <code>io.Reader</code>, <code>io.Writer</code>, <code>http.Request</code>, and more. This means that you can use many existing libraries with or alongside Huma.</p> <p>Be sure to check out the benchmarks!</p>"},{"location":"why/#routers","title":"Routers","text":"<p>Huma is router-agnostic and includes support for a handful of popular routers and their middleware your organization may already be using today:</p> <ul> <li>BunRouter</li> <li>chi</li> <li>gin</li> <li>Go 1.22+ <code>http.ServeMux</code></li> <li>gorilla/mux</li> <li>httprouter</li> <li>Fiber</li> </ul> <p>Huma meets you where you are and levels up your API and team.</p>"},{"location":"why/#extensibility","title":"Extensibility","text":"<p>Huma can be extended to support all your use-cases.</p>"},{"location":"why/#middleware","title":"Middleware","text":"<p>Flexible router-specific or router-agnostic middleware enables you to extend basic functionality with auth, metrics, traces, and more.</p> <p> Middleware</p>"},{"location":"why/#validation","title":"Validation","text":"<p>Huma has built-in support for validating input parameters and models using JSON Schema and/or custom Go code using resolvers, which can extend the built-in validation to do anything you want and returns exhaustive errors back to the user.</p> <p> Request Validation  Resolvers</p>"},{"location":"why/#openapi-schemas","title":"OpenAPI &amp; Schemas","text":"<p>The OpenAPI &amp; JSON Schema generation is completely customizable &amp; extensible. Huma provides low-level access and the ability to override or augment any generated specs and schemas.</p> <p> Configuration &amp; OpenAPI  JSON Schema &amp; Registry</p>"},{"location":"why/#guardrails","title":"Guardrails","text":"<p>Huma provides guardrails &amp; automation to keep your team and your services running as smoothly as possible, based on years of hard-learned lessons from many teams of engineers with a variety of skills and experience levels running and maintaining production systems at scale for millions of users.</p> <ul> <li>Service documentation that can't get out of date</li> <li>Strongly-typed models &amp; handlers with compile-time checks</li> <li>Automatic validation of input parameters and models</li> <li>Automatic serialization of responses based on client-driven content-negotiation</li> <li>Supports automatic CLI &amp; SDK generation</li> </ul> <p> Start the tutorial now</p>"},{"location":"why/#who-is-using-huma","title":"Who is using Huma?","text":"<p>Huma is used by a variety of companies and projects, from large-scale production services handling millions of requests to community-driven open-source tools.</p>"},{"location":"why/#production-at-scale","title":"Production at Scale","text":"<p>Huma powers critical services for some of the largest companies in the world:</p> <ul> <li>Corporate Adoption: We see regular traffic and adoption from FinTechs, Mercedes-Benz, and many other global companies.</li> <li>Roblox: The content catalog service uses Huma and handles over a million requests a second in production.</li> <li>Warner Bros. Discovery: Used to run major live events and services including the Olympics, March Madness, CNN, and more.</li> </ul>"},{"location":"why/#open-source-projects","title":"Open Source Projects","text":"<p>The following is a list of open-source projects using Huma. If you would like to see your project listed here, please open a pull request or issue to request it!</p> <ul> <li>AvengeMedia - dgop</li> <li>ckoliber - GoCRUD</li> <li>fy0 - CodeKanban</li> <li>Global Cyber Alliance - Domain Security Scanner</li> <li>Mozilla AI - MCPD</li> </ul>"},{"location":"why/benchmarks/","title":"Benchmarks","text":"<p>You should always perform your own benchmarking, as your use-case may not be identical to the use-cases of others. However, here are some general benchmarks to get you started.</p>"},{"location":"why/benchmarks/#go-performance","title":"Go Performance","text":"<p>Go is fast. When compared to Node.js and Python, Go is often much faster while using less memory and handling concurrency better. The Techempower benchmarks are a good place to start for a general comparison:</p> <p></p> <p>Notice that all the top frameworks are written in Go. Huma's performance and features will vary based on the specific router or framework used, but it is generally on par with the other top Go frameworks.</p> <p>Highlighting just a few is telling, and this ignores the improvements in memory use which likely means cheaper hardware and container costs:</p> Framework Language JSON Req/s Percentage Fortunes Req/s Percentage Chi Go 520K 100% 150K 100% Node.js Javascript 377K 73% 80K 53% FastAPI Python 168K 32% 50K 33% Django Python 73K 14% 15K 10%"},{"location":"why/benchmarks/#takeways","title":"Takeways","text":"<p>Here are a few takeaways of the above, other benchmarks, and our time with Go:</p> <ul> <li>Go (and thus Huma) is fast and low memory.</li> <li>Go is simple and can be picked up by a team quickly.<ul> <li>Its complexity is on par or less than Javascript or Python</li> </ul> </li> <li>Huma is a good choice over Node.js, FastAPI, or Django.</li> </ul>"},{"location":"why/benchmarks/#micro-benchmarks","title":"Micro Benchmarks","text":"<p>Significant performance improvements have been made since Huma v1, as shown by the following basic benchmark operation with a few input parameters, a small input body, some output headers and an output body (see <code>adapters/humachi/humachi_test.go</code>).</p> <pre><code># Huma v1\nBenchmarkHumaV1Chi-10         16285  112086 ns/op  852209 B/op  258 allocs/op\n\n# Huma v2\nBenchmarkHumaV2Chi-10        431028    2777 ns/op    1718 B/op   29 allocs/op\n\n# Chi without Huma (raw)\nBenchmarkRawChi-10           552764    2143 ns/op    2370 B/op   29 allocs/op\n</code></pre> <p>These improvements are due to a number of factors, including changes to the Huma API, precomputation of reflection data when possible, low or zero-allocation validation &amp; URL parsing, using shared buffer pools to limit garbage collector pressure, and more.</p> <p>Since you bring your own router, you are free to \"escape\" Huma by using the router directly, but as you can see above it's rarely needed with v2.</p>"},{"location":"why/what-about-design-first/","title":"What About Design First?","text":""},{"location":"why/what-about-design-first/#introduction","title":"Introduction","text":"<p>Design first is an API methodology that involves writing the API specification before writing any code. This is often presented in contrast to code first, where you write the code first and then generate the API specification from the code.</p> <pre><code>graph LR\n\tAPISpec[API Spec] --&gt; Review\n\tReview --&gt; APISpec\n\tReview --&gt; Code\n\tCode --&gt; Review2[Review]\n\tReview2 --&gt; Code\n\tReview2 --&gt; Deploy</code></pre>"},{"location":"why/what-about-design-first/#benefits","title":"Benefits","text":"<p>Design first enables you to think through the API, its use cases, and the big picture before just slapping together some code. It enables quick feedback and iteration on the API design.</p>"},{"location":"why/what-about-design-first/#false-dichotomy","title":"False Dichotomy","text":"<p>Fortunately, the \"design-first\" vs. \"code-first\" dichotomy is a false one. You can do both at the same time! In fact, Huma is designed to enable this by providing a way to write the skeleton code without any operation handler implementations which can be reviewed independently from the handlers.</p> <pre><code>graph LR\n\tHumaSkeleton[Huma Skeleton] --&gt; Review\n\tHumaSkeleton --&gt; OpenAPI[OpenAPI Spec]\n\tOpenAPI --&gt; Review\n\tReview --&gt; HumaSkeleton\n\tReview --&gt; HumaImplementation[Huma Implementation]\n\tHumaImplementation --&gt; Review2[Review]\n\tReview2 --&gt; HumaImplementation\n\tReview2 --&gt; Deploy</code></pre>"},{"location":"why/what-about-design-first/#example","title":"Example","text":"<p>Here's an example of part of the popular Pet Store API written as a skeleton in Huma, ready for review &amp; iteration either by reviewing the code or by generating the API specification and reviewing that.</p> main.go<pre><code>package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/spf13/cobra\"\n)\n\ntype Category struct {\n\tID   int    `json:\"id\" example:\"1\" doc:\"Category ID\"`\n\tName string `json:\"name\" example:\"Cats\" doc:\"Category name\"`\n}\n\ntype Tag struct {\n\tID   int    `json:\"id\" example:\"1\" doc:\"Tag ID\"`\n\tName string `json:\"name\" example:\"cute\" doc:\"Tag name\"`\n}\n\ntype Pet struct {\n\tID        int       `json:\"id\" example:\"1\" doc:\"Pet ID\"`\n\tCategory  *Category `json:\"category\" doc:\"Category that the pet belongs to\"`\n\tName      string    `json:\"name\" example:\"Fluffy\" doc:\"Pet name\"`\n\tPhotoURLs []string  `json:\"photoUrls\" example:\"https://example.com/fluffy.jpg\" doc:\"Photo URLs for the pet\"`\n\tTags      []Tag     `json:\"tags\" example:'[\"cute\"]' doc:\"Tags for the pet\"`\n\tStatus    string    `json:\"status\" example:\"available\" doc:\"Pet status\" enum:\"available,pending,sold\"`\n}\n\ntype PetID struct {\n\tID int `path:\"petId\" example:\"1\" doc:\"Pet ID\"`\n}\n\nfunc main() {\n\tvar api huma.API\n\n\tcli := humacli.New(func(hooks humacli.Hooks, options *struct{}) {\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"Pet Store\", \"1.0.0\"))\n\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"post-pet\",\n\t\t\tMethod:      \"POST\",\n\t\t\tPath:        \"/pet\",\n\t\t\tSummary:     \"Add a new pet\",\n\t\t}, func(ctx context.Context, input *struct {\n\t\t\tBody Pet\n\t\t}) (*struct{}, error) {\n\t\t\treturn nil, nil\n\t\t})\n\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-pet\",\n\t\t\tMethod:      \"GET\",\n\t\t\tPath:        \"/pet/{petId}\",\n\t\t\tSummary:     \"Get a pet\",\n\t\t}, func(ctx context.Context, input *PetID) (*struct {\n\t\t\tBody Pet\n\t\t}, error) {\n\t\t\treturn nil, nil\n\t\t})\n\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"find-pet-by-status\",\n\t\t\tMethod:      \"GET\",\n\t\t\tPath:        \"/pet/findByStatus\",\n\t\t\tSummary:     \"Find a pet by status\",\n\t\t}, func(ctx context.Context, input *struct {\n\t\t\tStatus string `path:\"status\" example:\"available\" doc:\"Status to filter by\" enum:\"available,pending,sold\"`\n\t\t}) (*struct {\n\t\t\tBody []Pet\n\t\t}, error) {\n\t\t\treturn nil, nil\n\t\t})\n\t})\n\n\tcli.Root().AddCommand(&amp;cobra.Command{\n\t\tUse: \"openapi\",\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tb, err := api.OpenAPI().MarshalJSON()\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tfmt.Println(string(b))\n\t\t},\n\t})\n\n\tcli.Run()\n}\n</code></pre>"}]}